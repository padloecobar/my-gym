#### START app/globals.css ####

@import "tailwindcss";

:root {
  color-scheme: light;
  --bg: #f4f6fb;
  --bg-elev: #f9fbff;
  --bg-card: #ffffff;
  --text: #1b1f2a;
  --muted: #5b6270;
  --accent: #3a6ff7;
  --accent-strong: #2f5de0;
  --accent-2: #1aa3a3;
  --accent-ink: #f8fbff;
  --danger: #d64545;
  --success: #2e9b66;
  --border: #e1e5ef;
  --chip: #edf1f8;
  --chip-active: #dce7ff;
  --shadow: 0 18px 40px rgba(22, 28, 45, 0.12);
  --radius-lg: 20px;
  --radius-md: 14px;
  --radius-sm: 10px;
  --grid: rgba(20, 24, 40, 0.06);
  --glow: rgba(58, 111, 247, 0.16);
  --glow-2: rgba(26, 163, 163, 0.14);
  --font-body: "Recursive", "IBM Plex Sans", "Source Sans 3", sans-serif;
  --font-display: "Unbounded", "Sora", "IBM Plex Sans", sans-serif;
  --font-code: "Azeret Mono", "IBM Plex Mono", "JetBrains Mono", monospace;
}

@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
    --bg: #0f1420;
    --bg-elev: #151c28;
    --bg-card: #1b2433;
    --text: #f1f4f8;
    --muted: #9aa3b2;
    --accent: #4f7dff;
    --accent-strong: #3b67f0;
    --accent-2: #2fb8b8;
    --accent-ink: #f8fbff;
    --danger: #f07171;
    --success: #4cc78a;
    --border: #2b3446;
    --chip: #232c3b;
    --chip-active: #2f3a4f;
    --shadow: 0 20px 40px rgba(7, 10, 18, 0.5);
    --grid: rgba(241, 244, 248, 0.05);
    --glow: rgba(79, 125, 255, 0.2);
    --glow-2: rgba(47, 184, 184, 0.16);
  }
}

@theme inline {
  --color-bg: var(--bg);
  --color-bg-elev: var(--bg-elev);
  --color-bg-card: var(--bg-card);
  --color-text: var(--text);
  --color-muted: var(--muted);
  --color-accent: var(--accent);
  --color-accent-strong: var(--accent-strong);
  --color-accent-2: var(--accent-2);
  --color-accent-ink: var(--accent-ink);
  --color-danger: var(--danger);
  --color-success: var(--success);
  --color-border: var(--border);
  --font-sans: var(--font-body);
  --font-serif: var(--font-display);
  --font-mono: var(--font-code);
}

* {
  box-sizing: border-box;
}

body {
  min-height: 100vh;
  background-color: var(--bg);
  background-image: radial-gradient(900px 600px at 8% -15%, var(--glow), transparent 60%),
    radial-gradient(900px 600px at 95% -10%, var(--glow-2), transparent 55%),
    repeating-linear-gradient(
      0deg,
      var(--grid) 0 1px,
      transparent 1px 24px
    ),
    repeating-linear-gradient(
      90deg,
      var(--grid) 0 1px,
      transparent 1px 24px
    );
  background-attachment: fixed;
  background-size: auto, auto, 24px 24px, 24px 24px;
  color: var(--text);
  font-family: var(--font-sans);
}

a {
  color: inherit;
  text-decoration: none;
}

button,
input,
textarea,
select {
  font: inherit;
}

:focus-visible {
  outline: 2px solid var(--accent-2);
  outline-offset: 2px;
}

::selection {
  background: rgba(255, 107, 44, 0.3);
}

@keyframes rise-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    scroll-behavior: auto !important;
    transition-duration: 0.01ms !important;
  }
}

#### END app/globals.css ####

#### START app/history/page.tsx ####

"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import AppShell from "../../components/AppShell";
import SetBuilder from "../../components/SetBuilder";
import SwipeRow from "../../components/SwipeRow";
import Toast from "../../components/Toast";
import { IconChevronDown, IconSearch } from "../../components/Icons";
import { useExercises } from "../../src/hooks/useExercises";
import { useSessions } from "../../src/hooks/useSessions";
import { useSets } from "../../src/hooks/useSets";
import { useSettings } from "../../src/hooks/useSettings";
import { computeTotals, formatKg, formatLb, toKg } from "../../lib/calc";
import {
  formatDateHeading,
  formatShortTime,
  getLocalDateKey,
} from "../../lib/date";
import type {
  Exercise,
  SessionEntry,
  SetEntry,
  SettingsState,
  WorkoutId,
} from "../../lib/types";

const SESSION_PAGE_SIZE = 14;

type SessionSummary = {
  date: string;
  setCount: number;
  exerciseCount: number;
  volumeLb: number;
  workoutId?: WorkoutId;
  exerciseOrder: string[];
  exerciseIds: string[];
};

const sortSessionsDesc = (sessions: SessionEntry[]) =>
  [...sessions].sort((a, b) => (a.date < b.date ? 1 : -1));

const sortSetsDesc = (sets: SetEntry[]) =>
  [...sets].sort((a, b) => b.ts - a.ts);

const buildSessionSummary = (
  date: string,
  sets: SetEntry[],
  session: SessionEntry | null,
  exercises: Exercise[],
  exerciseById: Map<string, Exercise>,
): SessionSummary | null => {
  if (!sets.length) return null;
  const exerciseIds = Array.from(new Set(sets.map((set) => set.exerciseId)));
  const workoutIds = new Set<WorkoutId>();
  exerciseIds.forEach((id) => {
    const workout = exerciseById.get(id)?.workout;
    if (workout) workoutIds.add(workout);
  });

  let inferredWorkout: WorkoutId | undefined;
  if (workoutIds.size === 1) {
    inferredWorkout = Array.from(workoutIds)[0];
  } else if (workoutIds.size > 1) {
    inferredWorkout = "Custom";
  }

  const resolvedWorkout = inferredWorkout ?? session?.workoutId;

  const snapshot = session?.exercisesSnapshot ?? [];
  let exerciseOrder = snapshot.filter((id) => exerciseIds.includes(id));

  if (!exerciseOrder.length && resolvedWorkout && workoutIds.size === 1) {
    exerciseOrder = exercises
      .filter(
        (exercise) =>
          exercise.workout === resolvedWorkout && exerciseIds.includes(exercise.id),
      )
      .sort((a, b) => a.order - b.order)
      .map((exercise) => exercise.id);
  }

  if (!exerciseOrder.length) {
    const firstByExercise = new Map<string, number>();
    [...sets]
      .sort((a, b) => a.ts - b.ts)
      .forEach((setEntry) => {
        if (!firstByExercise.has(setEntry.exerciseId)) {
          firstByExercise.set(setEntry.exerciseId, setEntry.ts);
        }
      });
    exerciseOrder = Array.from(firstByExercise.entries())
      .sort((a, b) => a[1] - b[1])
      .map(([exerciseId]) => exerciseId);
  }

  const volumeLb = sets.reduce(
    (sum, setEntry) => sum + setEntry.totalLb * setEntry.reps,
    0,
  );

  return {
    date,
    setCount: sets.length,
    exerciseCount: exerciseIds.length,
    volumeLb,
    workoutId: resolvedWorkout,
    exerciseOrder,
    exerciseIds,
  };
};

const HistoryPage = () => {
  const router = useRouter();
  const {
    exercises,
    loading: exercisesLoading,
    error: exercisesError,
  } = useExercises();
  const {
    sessions,
    setSessions,
    listSessions,
    getSession,
    saveSession,
    deleteSessionWithSets,
  } = useSessions({ autoLoad: false });
  const {
    querySetsByDate,
    addSet,
    updateSet,
    deleteSet,
  } = useSets({ autoLoad: false });
  const {
    settings,
    loading: settingsLoading,
    error: settingsError,
    updateSettings,
  } = useSettings();
  const [sessionSets, setSessionSets] = useState<Record<string, SetEntry[]>>({});
  const [summaries, setSummaries] = useState<Record<string, SessionSummary>>({});
  const [expandedDates, setExpandedDates] = useState<Record<string, boolean>>({});
  const [search, setSearch] = useState("");
  const [editingSet, setEditingSet] = useState<SetEntry | null>(null);
  const [toast, setToast] = useState<{ message: string; action?: () => void } | null>(
    null,
  );
  const toastTimer = useRef<number | null>(null);
  const initialLoadRef = useRef(false);
  const [loading, setLoading] = useState(true);
  const [hasMore, setHasMore] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);

  const exerciseById = useMemo(
    () => new Map(exercises.map((exercise) => [exercise.id, exercise])),
    [exercises],
  );

  const sessionByDate = useMemo(
    () => new Map(sessions.map((session) => [session.date, session])),
    [sessions],
  );

  const showLb = settings.unitDisplay === "both" || settings.unitDisplay === "lb";
  const showKg = settings.unitDisplay === "both" || settings.unitDisplay === "kg";

  const formatTotal = useCallback(
    (lb: number) => {
      const kg = toKg(lb, settings.roundingKg);
      return `${showLb ? `${formatLb(lb)} lb` : ""}${
        showLb && showKg ? " | " : ""
      }${showKg ? `${formatKg(kg, settings.roundingKg)} kg` : ""}`;
    },
    [settings.roundingKg, showKg, showLb],
  );

  const formatSetLabel = useCallback(
    (setEntry: SetEntry, exercise?: Exercise | null) => {
      if (!exercise) {
        return `${formatLb(setEntry.inputLb)}x${setEntry.reps}`;
      }
      if (exercise.type === "bodyweight") {
        return `BWx${setEntry.reps}`;
      }
      return `${formatLb(setEntry.inputLb)}x${setEntry.reps}`;
    },
    [],
  );

  const showToast = useCallback((message: string, action?: () => void) => {
    setToast({ message, action });
    if (toastTimer.current) {
      window.clearTimeout(toastTimer.current);
    }
    toastTimer.current = window.setTimeout(() => setToast(null), 3500);
  }, []);

  useEffect(() => {
    return () => {
      if (toastTimer.current) {
        window.clearTimeout(toastTimer.current);
      }
    };
  }, []);

  useEffect(() => {
    const errors = [exercisesError, settingsError].filter(Boolean);
    if (!errors.length) return;
    console.error("History page data error:", errors);
  }, [exercisesError, settingsError]);

  const applySetListUpdate = useCallback(
    (date: string, nextList: SetEntry[]) => {
      setSessionSets((prev) => {
        const next = { ...prev };
        if (nextList.length) {
          next[date] = sortSetsDesc(nextList);
        } else {
          delete next[date];
        }
        return next;
      });
      setSummaries((prev) => {
        const next = { ...prev };
        const session = sessionByDate.get(date) ?? null;
        const summary = buildSessionSummary(
          date,
          nextList,
          session,
          exercises,
          exerciseById,
        );
        if (summary) {
          next[date] = summary;
        } else {
          delete next[date];
        }
        return next;
      });
      if (!nextList.length) {
        setSessions((prev) => prev.filter((session) => session.date !== date));
        setExpandedDates((prev) => {
          const next = { ...prev };
          delete next[date];
          return next;
        });
      }
    },
    [
      exerciseById,
      exercises,
      sessionByDate,
      setExpandedDates,
      setSessionSets,
      setSessions,
      setSummaries,
    ],
  );

  const loadSessions = useCallback(
    async ({
      before,
      append,
      exerciseList,
      exerciseMap,
    }: {
      before?: string;
      append?: boolean;
      exerciseList?: Exercise[];
      exerciseMap?: Map<string, Exercise>;
    } = {}) => {
      const list = exerciseList ?? exercises;
      const map = exerciseMap ?? exerciseById;
      const { sessions: page, hasMore: nextHasMore } = await listSessions({
        limit: SESSION_PAGE_SIZE,
        before,
      });
      const results = await Promise.all(
        page.map(async (session) => {
          const setsForDate = await querySetsByDate(session.date);
          const summary = buildSessionSummary(
            session.date,
            setsForDate,
            session,
            list,
            map,
          );
          if (!summary) return null;
          return { session, summary, sets: setsForDate };
        }),
      );
      const valid = results.filter(Boolean) as Array<{
        session: SessionEntry;
        summary: SessionSummary;
        sets: SetEntry[];
      }>;
      const nextSessions = valid.map((item) => item.session);
      const nextSummaries = valid.reduce<Record<string, SessionSummary>>(
        (acc, item) => {
          acc[item.session.date] = item.summary;
          return acc;
        },
        {},
      );
      const nextSets = valid.reduce<Record<string, SetEntry[]>>((acc, item) => {
        acc[item.session.date] = item.sets;
        return acc;
      }, {});

      setSessions((prev) =>
        append ? sortSessionsDesc([...prev, ...nextSessions]) : nextSessions,
      );
      setSummaries((prev) => (append ? { ...prev, ...nextSummaries } : nextSummaries));
      setSessionSets((prev) => (append ? { ...prev, ...nextSets } : nextSets));
      setHasMore(nextHasMore);
    },
    [
      exerciseById,
      exercises,
      listSessions,
      querySetsByDate,
      setHasMore,
      setSessionSets,
      setSessions,
      setSummaries,
    ],
  );

  const handleLoadMore = useCallback(async () => {
    if (!hasMore || loadingMore) return;
    const lastDate = sessions[sessions.length - 1]?.date;
    if (!lastDate) return;
    setLoadingMore(true);
    try {
      await loadSessions({ before: lastDate, append: true });
    } finally {
      setLoadingMore(false);
    }
  }, [hasMore, loadSessions, loadingMore, sessions]);

  useEffect(() => {
    if (initialLoadRef.current) return;
    if (exercisesLoading || settingsLoading) return;
    initialLoadRef.current = true;
    const load = async () => {
      try {
        const exerciseMap = new Map(
          exercises.map((exercise) => [exercise.id, exercise]),
        );
        await loadSessions({ exerciseList: exercises, exerciseMap });
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };
    load();
  }, [exercises, exercisesLoading, loadSessions, settingsLoading]);

  const handleOpenSession = useCallback(
    async (date: string, workoutId?: WorkoutId) => {
      const updates: Partial<SettingsState> = { activeSessionDate: date };
      if (workoutId) {
        updates.lastWorkout = workoutId;
      }
      await updateSettings(updates);
      router.push("/");
    },
    [router, updateSettings],
  );

  const handleDuplicateAsToday = useCallback(
    async (session: SessionEntry, summary?: SessionSummary) => {
      const todayKey = getLocalDateKey();
      const existing = await getSession(todayKey);
      const workoutId = summary?.workoutId ?? session.workoutId;
      const exercisesSnapshot = summary?.exerciseOrder.length
        ? summary.exerciseOrder
        : session.exercisesSnapshot;
      const now = Date.now();
      const nextSession: SessionEntry = {
        date: todayKey,
        workoutId: workoutId ?? existing?.workoutId,
        createdAtTs: existing?.createdAtTs ?? now,
        updatedAtTs: now,
        notes: existing?.notes,
        exercisesSnapshot: exercisesSnapshot ?? existing?.exercisesSnapshot,
      };
      await saveSession(nextSession);
      const updates: Partial<SettingsState> = { activeSessionDate: todayKey };
      if (workoutId) {
        updates.lastWorkout = workoutId;
      }
      await updateSettings(updates);
      showToast("Duplicated for today.", () => {
        void handleOpenSession(todayKey, workoutId);
      });
    },
    [getSession, handleOpenSession, saveSession, showToast, updateSettings],
  );

  const handleDeleteSession = useCallback(
    async (date: string) => {
      const confirmed = window.confirm(
        "Delete this session and all sets for that date?",
      );
      if (!confirmed) return;
      await deleteSessionWithSets(date);
      setSessions((prev) => prev.filter((session) => session.date !== date));
      setSessionSets((prev) => {
        const next = { ...prev };
        delete next[date];
        return next;
      });
      setSummaries((prev) => {
        const next = { ...prev };
        delete next[date];
        return next;
      });
      setExpandedDates((prev) => {
        const next = { ...prev };
        delete next[date];
        return next;
      });
      showToast("Session deleted.");
    },
    [
      deleteSessionWithSets,
      setExpandedDates,
      setSessionSets,
      setSessions,
      setSummaries,
      showToast,
    ],
  );

  const handleDeleteSet = useCallback(
    async (setEntry: SetEntry) => {
      await deleteSet(setEntry.id);
      const currentList = sessionSets[setEntry.date] ?? [];
      const nextList = currentList.filter((item) => item.id !== setEntry.id);
      const wasLastSet = nextList.length === 0;
      applySetListUpdate(setEntry.date, nextList);
      const exercise = exerciseById.get(setEntry.exerciseId);
      showToast(`Deleted ${formatSetLabel(setEntry, exercise)}`, async () => {
        await addSet(setEntry);
        const restored = sortSetsDesc([...nextList, setEntry]);
        applySetListUpdate(setEntry.date, restored);
        if (wasLastSet) {
          const session = await getSession(setEntry.date);
          if (session) {
            setSessions((prev) => sortSessionsDesc([...prev, session]));
          }
        }
      });
    },
    [
      addSet,
      applySetListUpdate,
      deleteSet,
      exerciseById,
      formatSetLabel,
      getSession,
      sessionSets,
      setSessions,
      showToast,
    ],
  );

  const handleUpdate = useCallback(
    async (draft: {
      inputLb: number;
      reps: number;
      tags: string[];
      note: string;
      rpe?: number;
    }) => {
      if (!editingSet) return;
      const exercise = exerciseById.get(editingSet.exerciseId);
      if (!exercise) return;
      const perSide =
        exercise.type === "barbell" || exercise.type === "dumbbell"
          ? exercise.perSide ?? true
          : false;
      const totals = computeTotals(
        draft.inputLb,
        exercise.type,
        editingSet.barLbSnapshot,
        settings.roundingKg,
        perSide,
      );
      const updated: SetEntry = {
        ...editingSet,
        inputLb: draft.inputLb,
        reps: draft.reps,
        totalLb: totals.totalLb,
        totalKg: totals.totalKg,
        note: draft.note || undefined,
        tags: draft.tags.length ? draft.tags : undefined,
        meta: draft.rpe ? { rpe: draft.rpe } : undefined,
      };
      const previous = editingSet;
      await updateSet(updated);
      const currentList = sessionSets[updated.date] ?? [];
      const nextList = currentList.map((item) =>
        item.id === updated.id ? updated : item,
      );
      applySetListUpdate(updated.date, nextList);
      setEditingSet(null);
      showToast(`Updated ${formatSetLabel(updated, exercise)}`, async () => {
        await updateSet(previous);
        const reverted = nextList.map((item) =>
          item.id === previous.id ? previous : item,
        );
        applySetListUpdate(previous.date, reverted);
      });
    },
    [
      applySetListUpdate,
      editingSet,
      exerciseById,
      formatSetLabel,
      sessionSets,
      settings.roundingKg,
      showToast,
      updateSet,
    ],
  );

  const filteredSessions = useMemo(() => {
    if (!search.trim()) return sessions;
    const term = search.toLowerCase();
    return sessions.filter((session) => {
      const summary = summaries[session.date];
      if (!summary) return true;
      return summary.exerciseIds.some((exerciseId) => {
        const name = exerciseById.get(exerciseId)?.name ?? "";
        return name.toLowerCase().includes(term);
      });
    });
  }, [exerciseById, search, sessions, summaries]);

  return (
    <>
      <AppShell title="History">
        <div className="space-y-5">
          <div className="flex min-h-[56px] items-center gap-3 rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-3 shadow-[var(--shadow)]">
            <IconSearch className="h-5 w-5 text-[color:var(--muted)]" />
            <input
              value={search}
              onChange={(event) => setSearch(event.target.value)}
              placeholder="Find sessions"
              className="w-full bg-transparent text-sm text-[color:var(--text)] outline-none placeholder:text-[color:var(--muted)]"
            />
          </div>

          {loading ? (
            <div className="rounded-[var(--radius-lg)] border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
              Loading history...
            </div>
          ) : null}

          {!loading && filteredSessions.length
            ? filteredSessions.map((session) => {
                const summary = summaries[session.date];
                if (!summary) return null;
                const expanded = Boolean(expandedDates[session.date]);
                const setsForDate = sessionSets[session.date] ?? [];
                const workoutLabel = summary.workoutId
                  ? summary.workoutId === "Custom"
                    ? "Custom Session"
                    : `Workout ${summary.workoutId}`
                  : "Session";
                const summaryLine = `${summary.setCount} sets · ${summary.exerciseCount} exercises · ${formatTotal(
                  summary.volumeLb,
                )}`;
                const setsByExercise = new Map<string, SetEntry[]>();
                setsForDate.forEach((setEntry) => {
                  const list = setsByExercise.get(setEntry.exerciseId) ?? [];
                  list.push(setEntry);
                  setsByExercise.set(setEntry.exerciseId, list);
                });

                return (
                  <div
                    key={session.date}
                    className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]"
                  >
                    <div className="flex items-start justify-between gap-3">
                      <button
                        type="button"
                        onClick={() => handleOpenSession(session.date, summary.workoutId)}
                        className="flex-1 text-left"
                      >
                        <div className="flex items-center gap-2 text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)] font-mono">
                          <span className="h-2 w-2 rounded-full bg-[color:var(--accent)]" />
                          <span>{formatDateHeading(session.date)}</span>
                        </div>
                        <div className="mt-2 text-sm font-semibold text-[color:var(--text)] font-serif">
                          {workoutLabel}
                        </div>
                        <div className="mt-2 text-xs text-[color:var(--muted)]">
                          {summaryLine}
                        </div>
                      </button>
                      <button
                        type="button"
                        onClick={() =>
                          setExpandedDates((prev) => ({
                            ...prev,
                            [session.date]: !prev[session.date],
                          }))
                        }
                        className="min-h-[44px] rounded-full border border-[var(--border)] bg-[color:var(--bg-elev)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
                        aria-expanded={expanded}
                        aria-controls={`session-${session.date}`}
                      >
                        <span className="flex items-center gap-2">
                          Details
                          <IconChevronDown
                            className={`h-3 w-3 transition ${expanded ? "rotate-180" : ""}`}
                          />
                        </span>
                      </button>
                    </div>
                    <div className="mt-4 flex flex-wrap gap-2">
                      <button
                        type="button"
                        onClick={() => handleOpenSession(session.date, summary.workoutId)}
                        className="min-h-[40px] rounded-full border border-[var(--border)] bg-[color:var(--accent)] px-4 text-[10px] uppercase tracking-[0.3em] text-[color:var(--accent-ink)]"
                      >
                        Open in Log
                      </button>
                      <button
                        type="button"
                        onClick={() => handleDuplicateAsToday(session, summary)}
                        className="min-h-[40px] rounded-full border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 text-[10px] uppercase tracking-[0.3em] text-[color:var(--text)]"
                      >
                        Duplicate as Today
                      </button>
                      <button
                        type="button"
                        onClick={() => handleDeleteSession(session.date)}
                        className="min-h-[40px] rounded-full border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 text-[10px] uppercase tracking-[0.3em] text-[color:var(--danger)]"
                      >
                        Delete Session
                      </button>
                    </div>

                    {expanded ? (
                      <div
                        id={`session-${session.date}`}
                        className="mt-5 space-y-4 animate-[fade-in_0.25s_ease-out]"
                      >
                        {summary.exerciseOrder.map((exerciseId) => {
                          const exercise = exerciseById.get(exerciseId);
                          const exerciseSets = setsByExercise.get(exerciseId) ?? [];
                          if (!exerciseSets.length) return null;
                          const isBodyweight = exercise?.type === "bodyweight";
                          const isBarbell = exercise?.type === "barbell";
                          const isDumbbell = exercise?.type === "dumbbell";
                          const perSide = isBarbell || isDumbbell ? exercise?.perSide ?? true : false;
                          return (
                            <div key={exerciseId} className="space-y-2">
                              <div className="text-sm font-semibold text-[color:var(--text)] font-serif">
                                {exercise?.name ?? "Unknown exercise"}
                              </div>
                              {exerciseSets.map((setEntry) => {
                                const barbellDetail = isBarbell
                                  ? perSide
                                    ? `Per side ${formatLb(setEntry.inputLb)} lb + bar ${setEntry.barLbSnapshot} lb`
                                    : `Total ${formatLb(setEntry.inputLb)} lb (bar ${setEntry.barLbSnapshot} lb)`
                                  : null;
                                const dumbbellDetail = isDumbbell
                                  ? perSide
                                    ? `Per dumbbell ${formatLb(setEntry.inputLb)} lb`
                                    : `Total load ${formatLb(setEntry.inputLb)} lb`
                                  : null;
                                return (
                                  <SwipeRow
                                    key={setEntry.id}
                                    onDelete={() => handleDeleteSet(setEntry)}
                                  >
                                    <button
                                      type="button"
                                      onClick={() => setEditingSet(setEntry)}
                                      className="flex min-h-[56px] w-full items-center justify-between rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 py-2 text-left"
                                    >
                                      <div>
                                        <div className="text-sm font-semibold text-[color:var(--text)] font-mono">
                                          {exercise?.type === "bodyweight"
                                            ? `BWx${setEntry.reps}`
                                            : `${formatLb(setEntry.inputLb)}x${setEntry.reps}`}
                                        </div>
                                        <div className="text-xs text-[color:var(--muted)]">
                                          {formatShortTime(setEntry.ts)}
                                        </div>
                                        {barbellDetail ? (
                                          <div className="mt-1 text-[10px] uppercase tracking-[0.25em] text-[color:var(--muted)]">
                                            {barbellDetail}
                                          </div>
                                        ) : null}
                                        {dumbbellDetail ? (
                                          <div className="mt-1 text-[10px] uppercase tracking-[0.25em] text-[color:var(--muted)]">
                                            {dumbbellDetail}
                                          </div>
                                        ) : null}
                                      </div>
                                      <div className="text-right text-xs text-[color:var(--muted)]">
                                        {!isBodyweight ? (
                                          <div className="font-mono">
                                            {formatTotal(setEntry.totalLb)}
                                          </div>
                                        ) : (
                                          <div>Bodyweight</div>
                                        )}
                                        {setEntry.tags?.length ? (
                                          <div className="mt-1 text-[color:var(--text)] font-mono">
                                            {setEntry.tags.join(" / ")}
                                          </div>
                                        ) : null}
                                      </div>
                                    </button>
                                  </SwipeRow>
                                );
                              })}
                            </div>
                          );
                        })}
                      </div>
                    ) : null}
                  </div>
                );
              })
            : null}

          {!loading && !filteredSessions.length ? (
            <div className="rounded-[var(--radius-lg)] border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
              No sessions logged yet.
            </div>
          ) : null}

          {hasMore ? (
            <button
              type="button"
              onClick={handleLoadMore}
              disabled={loadingMore}
              className="min-h-[48px] w-full rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] text-[10px] uppercase tracking-[0.3em] text-[color:var(--text)] disabled:opacity-60"
            >
              {loadingMore ? "Loading..." : "Load older sessions"}
            </button>
          ) : null}
        </div>
      </AppShell>

      <SetBuilder
        open={Boolean(editingSet)}
        mode="edit"
        exercise={editingSet ? exerciseById.get(editingSet.exerciseId) ?? null : null}
        settings={
          editingSet ? { ...settings, barLb: editingSet.barLbSnapshot } : settings
        }
        initial={editingSet}
        onClose={() => setEditingSet(null)}
        onSave={handleUpdate}
        onDelete={() => {
          if (!editingSet) return;
          handleDeleteSet(editingSet);
          setEditingSet(null);
        }}
      />

      {toast ? (
        <Toast
          message={toast.message}
          actionLabel={toast.action ? "Undo" : undefined}
          onAction={() => {
            toast.action?.();
            setToast(null);
          }}
          onClose={() => setToast(null)}
        />
      ) : null}
    </>
  );
};

export default HistoryPage;

#### END app/history/page.tsx ####

#### START app/layout.tsx ####

import type { Metadata, Viewport } from "next";
import { Azeret_Mono, Recursive, Unbounded } from "next/font/google";
import "./globals.css";
import PwaRegister from "../components/PwaRegister";

const displayFont = Unbounded({
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
  variable: "--font-display",
  display: "swap",
});

const bodyFont = Recursive({
  subsets: ["latin"],
  weight: ["400", "500", "600"],
  variable: "--font-body",
  display: "swap",
});

const monoFont = Azeret_Mono({
  subsets: ["latin"],
  weight: ["400", "500", "600"],
  variable: "--font-code",
  display: "swap",
});

export const metadata: Metadata = {
  title: "Gym Log",
  description: "Low-tap gym logging with barbell math built in.",
  applicationName: "Gym Log",
  manifest: "/manifest.json",
  icons: {
    icon: "/icons/icon-192.svg",
    apple: "/icons/icon-192.svg",
  },
  appleWebApp: {
    capable: true,
    title: "Gym Log",
    statusBarStyle: "default",
  },
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "#f5f1e8" },
    { media: "(prefers-color-scheme: dark)", color: "#0f1110" },
  ],
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html
      lang="en"
      className={`${displayFont.variable} ${bodyFont.variable} ${monoFont.variable}`}
    >
      <body className="min-h-screen font-sans antialiased">
        {children}
        <PwaRegister />
      </body>
    </html>
  );
}

#### END app/layout.tsx ####

#### START app/page.tsx ####

"use client";

import { useCallback, useEffect, useMemo, useRef, useState, type PointerEvent } from "react";
import Link from "next/link";
import AppShell from "../components/AppShell";
import BottomSheet from "../components/BottomSheet";
import Onboarding from "../components/Onboarding";
import SetComposer, { type SetDraft } from "../components/SetComposer";
import Toast from "../components/Toast";
import {
  IconChevronDown,
  IconSettings,
  IconTimer,
} from "../components/Icons";
import { useExercises } from "../src/hooks/useExercises";
import { useSessions } from "../src/hooks/useSessions";
import { useSets } from "../src/hooks/useSets";
import { useSettings } from "../src/hooks/useSettings";
import { computeTotals, formatLb } from "../lib/calc";
import {
  formatDateHeading,
  formatSessionDateLabel,
  formatShortTime,
  getLocalDateKey,
} from "../lib/date";
import { createDefaultExercises, defaultSettings } from "../lib/defaults";
import type {
  Exercise,
  SessionEntry,
  SetEntry,
  SettingsState,
  WorkoutId,
} from "../lib/types";

const typeLabel = (type: Exercise["type"]) => {
  switch (type) {
    case "barbell":
      return "Barbell";
    case "dumbbell":
      return "Dumbbell";
    case "machine":
      return "Machine";
    case "bodyweight":
      return "Bodyweight";
    default:
      return type;
  }
};

const getWeightStep = (exercise: Exercise) => {
  if (exercise.type === "barbell") {
    return exercise.perSide ?? true ? 2.5 : 5;
  }
  return 5;
};

const getModeLabel = (exercise: Exercise) => {
  if (exercise.type === "barbell") {
    return exercise.perSide ?? true ? "Per side" : "Total on bar";
  }
  if (exercise.type === "dumbbell") {
    return exercise.perSide ?? true ? "Per dumbbell" : "Total load";
  }
  if (exercise.type === "bodyweight") {
    return "Reps only";
  }
  return "Weight";
};

const LogPage = () => {
  const {
    exercises,
    loading: exercisesLoading,
    error: exercisesError,
    saveExercises,
  } = useExercises();
  const {
    sessions,
    loading: sessionsLoading,
    error: sessionsError,
    getSession,
    setSessions,
  } = useSessions();
  const {
    sets,
    loading: setsLoading,
    error: setsError,
    addSet,
    deleteSet,
    setSets,
    updateSet,
  } = useSets();
  const {
    settings,
    loading: settingsLoading,
    error: settingsError,
    updateSettings,
    replaceSettings,
  } = useSettings();
  const loading = exercisesLoading || sessionsLoading || setsLoading || settingsLoading;
  const [selectedWorkout, setSelectedWorkout] = useState<WorkoutId | null>(null);
  const [sessionPickerOpen, setSessionPickerOpen] = useState(false);
  const [composerOpen, setComposerOpen] = useState(false);
  const [composerSeed, setComposerSeed] = useState<{ inputLb: number; reps: number } | null>(
    null,
  );
  const [editingSet, setEditingSet] = useState<SetEntry | null>(null);
  const [toast, setToast] = useState<{ message: string; action?: () => void } | null>(
    null,
  );
  const toastTimer = useRef<number | null>(null);
  const [activeIndex, setActiveIndex] = useState(0);
  const carouselRef = useRef<HTMLDivElement | null>(null);
  const scrollRaf = useRef<number | null>(null);
  const [restTimerEndsAt, setRestTimerEndsAt] = useState<number | null>(null);
  const [restTick, setRestTick] = useState(0);
  const [calendarOpen, setCalendarOpen] = useState(false);
  const [calendarMonthOverride, setCalendarMonthOverride] = useState<{
    year: number;
    month: number;
  } | null>(null);
  const gestureRef = useRef<{
    startX: number;
    startY: number;
    active: boolean;
    triggered: boolean;
    skipClick: boolean;
    longPressTimer: number | null;
  }>({
    startX: 0,
    startY: 0,
    active: false,
    triggered: false,
    skipClick: false,
    longPressTimer: null,
  });

  useEffect(() => {
    return () => {
      if (toastTimer.current) {
        window.clearTimeout(toastTimer.current);
      }
      if (scrollRaf.current) {
        window.cancelAnimationFrame(scrollRaf.current);
      }
    };
  }, []);

  useEffect(() => {
    const errors = [exercisesError, sessionsError, setsError, settingsError].filter(
      Boolean,
    );
    if (!errors.length) return;
    console.error("Log page data error:", errors);
  }, [exercisesError, sessionsError, setsError, settingsError]);

  const workouts = useMemo<WorkoutId[]>(() => {
    const hasCustom = exercises.some((exercise) => exercise.workout === "Custom");
    const base: WorkoutId[] = ["A", "B"];
    if (hasCustom) base.push("Custom");
    return base;
  }, [exercises]);

  const resolvedWorkout =
    selectedWorkout && workouts.includes(selectedWorkout)
      ? selectedWorkout
      : settings.lastWorkout && workouts.includes(settings.lastWorkout)
        ? settings.lastWorkout
        : workouts[0] ?? "A";
  const activeWorkout = resolvedWorkout;

  const exercisesForWorkout = useMemo(() => {
    return exercises
      .filter((exercise) => exercise.workout === activeWorkout)
      .sort((a, b) => a.order - b.order);
  }, [activeWorkout, exercises]);

  const resolvedActiveIndex = Math.min(
    activeIndex,
    Math.max(0, exercisesForWorkout.length - 1),
  );

  const todayKey = getLocalDateKey();
  const activeSessionDate =
    typeof settings.activeSessionDate === "string"
      ? settings.activeSessionDate
      : todayKey;
  const calendarMonth =
    calendarMonthOverride ??
    (() => {
      const activeDate = new Date(activeSessionDate);
      return { year: activeDate.getFullYear(), month: activeDate.getMonth() };
    })();
  const sessionDateLabel = formatSessionDateLabel(activeSessionDate, todayKey);
  const sessionBarDates = useMemo(() => {
    const dates = sessions
      .map((session) => session.date)
      .filter((date) => date <= todayKey);
    const list = [todayKey, activeSessionDate, ...dates];
    const unique = new Set<string>();
    return list.filter((date) => {
      if (unique.has(date)) return false;
      unique.add(date);
      return true;
    });
  }, [activeSessionDate, sessions, todayKey]);

  const workoutDateSet = useMemo(
    () => new Set(sessions.map((session) => session.date)),
    [sessions],
  );

  const calendarMonthLabel = useMemo(() => {
    const date = new Date(calendarMonth.year, calendarMonth.month, 1);
    return date.toLocaleDateString(undefined, {
      month: "long",
      year: "numeric",
    });
  }, [calendarMonth.month, calendarMonth.year]);

  const calendarDays = useMemo(() => {
    const days: Array<{
      dateKey: string;
      day: number;
      isToday: boolean;
      isActive: boolean;
      hasWorkout: boolean;
    } | null> = [];
    const firstDay = new Date(calendarMonth.year, calendarMonth.month, 1);
    const startWeekday = firstDay.getDay();
    const daysInMonth = new Date(
      calendarMonth.year,
      calendarMonth.month + 1,
      0,
    ).getDate();
    const totalCells = Math.ceil((startWeekday + daysInMonth) / 7) * 7;
    for (let i = 0; i < totalCells; i += 1) {
      const dayNumber = i - startWeekday + 1;
      if (dayNumber < 1 || dayNumber > daysInMonth) {
        days.push(null);
        continue;
      }
      const dateKey = `${calendarMonth.year}-${String(
        calendarMonth.month + 1,
      ).padStart(2, "0")}-${String(dayNumber).padStart(2, "0")}`;
      days.push({
        dateKey,
        day: dayNumber,
        isToday: dateKey === todayKey,
        isActive: dateKey === activeSessionDate,
        hasWorkout: workoutDateSet.has(dateKey),
      });
    }
    return days;
  }, [
    activeSessionDate,
    calendarMonth.month,
    calendarMonth.year,
    todayKey,
    workoutDateSet,
  ]);

  const openCalendar = useCallback(() => {
    const date = new Date(activeSessionDate);
    setCalendarMonthOverride({ year: date.getFullYear(), month: date.getMonth() });
    setCalendarOpen(true);
  }, [activeSessionDate]);

  const handlePrevMonth = useCallback(() => {
    setCalendarMonthOverride((prev) => {
      const base = prev ?? calendarMonth;
      const nextMonth = base.month - 1;
      if (nextMonth < 0) {
        return { year: base.year - 1, month: 11 };
      }
      return { year: base.year, month: nextMonth };
    });
  }, [calendarMonth]);

  const handleNextMonth = useCallback(() => {
    setCalendarMonthOverride((prev) => {
      const base = prev ?? calendarMonth;
      const nextMonth = base.month + 1;
      if (nextMonth > 11) {
        return { year: base.year + 1, month: 0 };
      }
      return { year: base.year, month: nextMonth };
    });
  }, [calendarMonth]);

  const { lastSetByExercise, sessionSetsByExercise } = useMemo(() => {
    const lastMap = new Map<string, SetEntry>();
    const sessionMap = new Map<string, SetEntry[]>();
    sets.forEach((set) => {
      if (!lastMap.has(set.exerciseId)) {
        lastMap.set(set.exerciseId, set);
      }
      if (set.date === activeSessionDate) {
        const list = sessionMap.get(set.exerciseId) ?? [];
        list.push(set);
        sessionMap.set(set.exerciseId, list);
      }
    });
    return { lastSetByExercise: lastMap, sessionSetsByExercise: sessionMap };
  }, [activeSessionDate, sets]);

  const workoutMeta = useMemo(() => {
    return workouts.map((workout) => {
      const list = exercises
        .filter((exercise) => exercise.workout === workout)
        .sort((a, b) => a.order - b.order);
      const focus = list.slice(0, 2).map((exercise) => exercise.name).join(" + ");
      const completed = list.filter(
        (exercise) => (sessionSetsByExercise.get(exercise.id) ?? []).length > 0,
      ).length;
      const setCount = list.reduce(
        (total, exercise) =>
          total + (sessionSetsByExercise.get(exercise.id) ?? []).length,
        0,
      );
      return {
        workout,
        focus,
        total: list.length,
        completed,
        setCount,
      };
    });
  }, [exercises, sessionSetsByExercise, workouts]);

  const activeMeta = workoutMeta.find((meta) => meta.workout === activeWorkout);
  const activeCompleted = activeMeta?.completed ?? 0;
  const activeSetCount = activeMeta?.setCount ?? 0;

  const activeExercise = exercisesForWorkout[resolvedActiveIndex] ?? null;
  const lastSet = activeExercise
    ? lastSetByExercise.get(activeExercise.id) ?? null
    : null;
  const sessionSets = activeExercise
    ? sessionSetsByExercise.get(activeExercise.id) ?? []
    : [];

  const exerciseById = useMemo(() => {
    return new Map(exercises.map((exercise) => [exercise.id, exercise]));
  }, [exercises]);

  const needsOnboarding = !settings.onboarded || exercises.length === 0;

  const sortSessionsDesc = useCallback(
    (items: SessionEntry[]) =>
      [...items].sort((a, b) => (a.date < b.date ? 1 : -1)),
    [],
  );

  const refreshSessionDate = useCallback(
    async (date: string) => {
      const session = await getSession(date);
      if (!session) return;
      setSessions((prev) => {
        const next = prev.filter((item) => item.date !== date);
        next.push(session);
        return sortSessionsDesc(next);
      });
    },
    [getSession, setSessions, sortSessionsDesc],
  );

  const removeSessionDate = useCallback((date: string) => {
    setSessions((prev) => prev.filter((item) => item.date !== date));
  }, [setSessions]);

  const updateSessionDate = useCallback(
    async (nextDate: string) => {
      if (!nextDate) return;
      const date = new Date(nextDate);
      setCalendarMonthOverride({
        year: date.getFullYear(),
        month: date.getMonth(),
      });
      await updateSettings({ activeSessionDate: nextDate });
    },
    [updateSettings],
  );

  const showToast = useCallback((message: string, action?: () => void) => {
    setToast({ message, action });
    if (toastTimer.current) {
      window.clearTimeout(toastTimer.current);
    }
    toastTimer.current = window.setTimeout(() => setToast(null), 4000);
  }, []);

  const triggerHaptic = useCallback((pattern: number | number[]) => {
    if (typeof navigator === "undefined") return;
    if ("vibrate" in navigator) {
      navigator.vibrate(pattern);
    }
  }, []);

  const formatSetLabel = useCallback((entry: SetEntry, exercise: Exercise) => {
    return exercise.type === "bodyweight"
      ? `BWx${entry.reps}`
      : `${formatLb(entry.inputLb)}x${entry.reps}`;
  }, []);

  const createSetEntry = useCallback(
    (
      exercise: Exercise,
      draft: {
        inputLb: number;
        reps: number;
        tags: string[];
        note: string;
        rpe?: number;
      },
    ): SetEntry => {
      const ts = Date.now();
      const barLbSnapshot = settings.barLb;
      const perSide =
        exercise.type === "barbell" || exercise.type === "dumbbell"
          ? exercise.perSide ?? true
          : false;
      const totals = computeTotals(
        draft.inputLb,
        exercise.type,
        barLbSnapshot,
        settings.roundingKg,
        perSide,
      );
      return {
        id: crypto.randomUUID(),
        ts,
        date: activeSessionDate,
        exerciseId: exercise.id,
        reps: draft.reps,
        inputLb: draft.inputLb,
        barLbSnapshot,
        totalLb: totals.totalLb,
        totalKg: totals.totalKg,
        note: draft.note || undefined,
        tags: draft.tags.length ? draft.tags : undefined,
        meta: draft.rpe ? { rpe: draft.rpe } : undefined,
      };
    },
    [activeSessionDate, settings.barLb, settings.roundingKg],
  );

  const handleAddSet = useCallback(
    async (
      exercise: Exercise,
      draft: {
        inputLb: number;
        reps: number;
        tags: string[];
        note: string;
        rpe?: number;
      },
      options?: { silent?: boolean },
    ) => {
      const entry = createSetEntry(exercise, draft);
      try {
        await addSet(entry);
        setSets((prev) => [entry, ...prev]);
        await refreshSessionDate(entry.date);
        await updateSettings({ lastWorkout: exercise.workout });
        triggerHaptic(8);
        if (!options?.silent) {
          showToast(`Logged ${formatSetLabel(entry, exercise)}`, async () => {
            await deleteSet(entry.id);
            setSets((prev) => {
              const next = prev.filter((item) => item.id !== entry.id);
              const stillHasDate = next.some((item) => item.date === entry.date);
              if (!stillHasDate) {
                removeSessionDate(entry.date);
              }
              return next;
            });
          });
        }
      } catch (error) {
        console.error(error);
        showToast("Could not save set");
      }
    },
    [
      addSet,
      createSetEntry,
      deleteSet,
      formatSetLabel,
      refreshSessionDate,
      removeSessionDate,
      setSets,
      showToast,
      triggerHaptic,
      updateSettings,
    ],
  );

  const handleOnboardingComplete = useCallback(async (barLb: number) => {
    const seeded = createDefaultExercises();
    const nextSettings: SettingsState = {
      ...defaultSettings,
      barLb,
      activeSessionDate,
      onboarded: true,
    };
    await saveExercises(seeded);
    await replaceSettings(nextSettings);
  }, [activeSessionDate, replaceSettings, saveExercises]);

  const handleUndoToday = useCallback(
    async (exerciseId: string) => {
      const sessionSetsList = sessionSetsByExercise.get(exerciseId) ?? [];
      const latest = sessionSetsList[0];
      if (!latest) {
        showToast("No sets to undo.");
        return;
      }
      await deleteSet(latest.id);
      setSets((prev) => {
        const next = prev.filter((item) => item.id !== latest.id);
        const stillHasDate = next.some((item) => item.date === latest.date);
        if (!stillHasDate) {
          removeSessionDate(latest.date);
        }
        return next;
      });
      showToast("Undid last set.");
    },
    [deleteSet, removeSessionDate, sessionSetsByExercise, setSets, showToast],
  );

  const handleEditUpdate = useCallback(
    async (draft: SetDraft) => {
      if (!editingSet) return;
      const exercise = exerciseById.get(editingSet.exerciseId);
      if (!exercise) return;
      const perSide =
        exercise.type === "barbell" || exercise.type === "dumbbell"
          ? exercise.perSide ?? true
          : false;
      const totals = computeTotals(
        draft.inputLb,
        exercise.type,
        editingSet.barLbSnapshot,
        settings.roundingKg,
        perSide,
      );
      const updated: SetEntry = {
        ...editingSet,
        inputLb: draft.inputLb,
        reps: draft.reps,
        totalLb: totals.totalLb,
        totalKg: totals.totalKg,
        note: draft.note || undefined,
        tags: draft.tags.length ? draft.tags : undefined,
        meta: draft.rpe ? { rpe: draft.rpe } : undefined,
      };
      await updateSet(updated);
      setSets((prev) => prev.map((item) => (item.id === updated.id ? updated : item)));
      setEditingSet(null);
      showToast(`Updated ${formatSetLabel(updated, exercise)}`);
    },
    [
      editingSet,
      exerciseById,
      formatSetLabel,
      settings.roundingKg,
      setSets,
      showToast,
      updateSet,
    ],
  );

  const handleEditDelete = useCallback(async () => {
    if (!editingSet) return;
    const exercise = exerciseById.get(editingSet.exerciseId);
    await deleteSet(editingSet.id);
    setSets((prev) => {
      const next = prev.filter((item) => item.id !== editingSet.id);
      const stillHasDate = next.some((item) => item.date === editingSet.date);
      if (!stillHasDate) {
        removeSessionDate(editingSet.date);
      }
      return next;
    });
    setEditingSet(null);
    if (exercise) {
      showToast(`Deleted ${formatSetLabel(editingSet, exercise)}`, async () => {
        await addSet(editingSet);
        setSets((prev) => [editingSet, ...prev]);
        await refreshSessionDate(editingSet.date);
      });
    } else {
      showToast("Deleted set");
    }
  }, [
    addSet,
    deleteSet,
    editingSet,
    exerciseById,
    formatSetLabel,
    refreshSessionDate,
    removeSessionDate,
    setSets,
    showToast,
  ]);

  const handleDeleteSet = useCallback(
    async (entry: SetEntry) => {
      await deleteSet(entry.id);
      setSets((prev) => {
        const next = prev.filter((item) => item.id !== entry.id);
        const stillHasDate = next.some((item) => item.date === entry.date);
        if (!stillHasDate) {
          removeSessionDate(entry.date);
        }
        return next;
      });
      const exercise = exerciseById.get(entry.exerciseId);
      if (exercise) {
        showToast(`Deleted ${formatSetLabel(entry, exercise)}`, async () => {
          await addSet(entry);
          setSets((prev) => [entry, ...prev]);
          await refreshSessionDate(entry.date);
        });
      } else {
        showToast("Deleted set");
      }
    },
    [
      addSet,
      deleteSet,
      exerciseById,
      formatSetLabel,
      refreshSessionDate,
      removeSessionDate,
      setSets,
      showToast,
    ],
  );

  const handleToggleWarmup = useCallback(
    async (entry: SetEntry) => {
      const nextTags = new Set(entry.tags ?? []);
      if (nextTags.has("warmup")) {
        nextTags.delete("warmup");
      } else {
        nextTags.add("warmup");
      }
      const updated: SetEntry = {
        ...entry,
        tags: nextTags.size ? Array.from(nextTags) : undefined,
      };
      await updateSet(updated);
      setSets((prev) => prev.map((item) => (item.id === updated.id ? updated : item)));
    },
    [setSets, updateSet],
  );

  const suggestedSet = useMemo(() => {
    if (!activeExercise) return null;
    const repPresets = [...settings.repPresets].sort((a, b) => a - b);
    const repCeiling = repPresets[repPresets.length - 1] ?? 12;
    const repDrop = repPresets[Math.max(0, repPresets.length - 3)] ?? 8;
    const baseReps = lastSet?.reps ?? repPresets[1] ?? 8;
    const baseWeight =
      activeExercise.type === "bodyweight"
        ? 0
        : lastSet?.inputLb ?? settings.weightPresets[2] ?? settings.barLb;
    if (!lastSet) {
      return {
        inputLb: baseWeight,
        reps: baseReps,
        recommended: false,
      };
    }
    if (activeExercise.type === "bodyweight") {
      const shouldProgress = lastSet.reps >= repCeiling;
      return {
        inputLb: 0,
        reps: shouldProgress ? lastSet.reps + 1 : lastSet.reps,
        recommended: shouldProgress,
      };
    }
    const shouldProgress = lastSet.reps >= repCeiling;
    return {
      inputLb: shouldProgress ? lastSet.inputLb + getWeightStep(activeExercise) : lastSet.inputLb,
      reps: shouldProgress ? repDrop : lastSet.reps,
      recommended: shouldProgress,
    };
  }, [activeExercise, lastSet, settings.barLb, settings.repPresets, settings.weightPresets]);

  const handleLogPrimary = useCallback(
    async (count = 1) => {
      if (!activeExercise || !suggestedSet) return;
      for (let i = 0; i < count; i += 1) {
        await handleAddSet(
          activeExercise,
          {
            inputLb: suggestedSet.inputLb,
            reps: suggestedSet.reps,
            tags: [],
            note: "",
          },
          { silent: i < count - 1 },
        );
      }
    },
    [activeExercise, handleAddSet, suggestedSet],
  );

  const startRestTimer = useCallback(() => {
    setRestTimerEndsAt(Date.now() + 90 * 1000);
    setRestTick(Date.now());
  }, []);

  useEffect(() => {
    if (!restTimerEndsAt) return;
    const id = window.setInterval(() => {
      const now = Date.now();
      setRestTick(now);
      if (now >= restTimerEndsAt) {
        window.clearInterval(id);
        setRestTimerEndsAt(null);
        showToast("Rest complete.");
      }
    }, 1000);
    return () => window.clearInterval(id);
  }, [restTimerEndsAt, showToast]);

  const restRemaining = restTimerEndsAt
    ? Math.max(0, Math.ceil((restTimerEndsAt - restTick) / 1000))
    : 0;


  const handleScroll = useCallback(() => {
    if (scrollRaf.current) return;
    scrollRaf.current = window.requestAnimationFrame(() => {
      scrollRaf.current = null;
      const node = carouselRef.current;
      if (!node) return;
      const width = node.clientWidth;
      if (!width) return;
      const nextIndex = Math.round(node.scrollLeft / width);
      setActiveIndex((prev) => (prev === nextIndex ? prev : nextIndex));
    });
  }, []);

  const handlePointerDown = useCallback(
    (event: PointerEvent<HTMLButtonElement>) => {
      if (!activeExercise) return;
      gestureRef.current.active = true;
      gestureRef.current.triggered = false;
      gestureRef.current.skipClick = false;
      gestureRef.current.startX = event.clientX;
      gestureRef.current.startY = event.clientY;
      if (gestureRef.current.longPressTimer) {
        window.clearTimeout(gestureRef.current.longPressTimer);
      }
      gestureRef.current.longPressTimer = window.setTimeout(() => {
        gestureRef.current.triggered = true;
        gestureRef.current.skipClick = true;
        if (suggestedSet) {
          setComposerSeed({ inputLb: suggestedSet.inputLb, reps: suggestedSet.reps });
        }
        setComposerOpen(true);
      }, 520);
    },
    [activeExercise, suggestedSet],
  );

  const handlePointerMove = useCallback(
    (event: PointerEvent<HTMLButtonElement>) => {
      if (!gestureRef.current.active || gestureRef.current.triggered) return;
      const dx = event.clientX - gestureRef.current.startX;
      const dy = event.clientY - gestureRef.current.startY;
      const threshold = 32;
      if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
      if (gestureRef.current.longPressTimer) {
        window.clearTimeout(gestureRef.current.longPressTimer);
        gestureRef.current.longPressTimer = null;
      }
      gestureRef.current.triggered = true;
      gestureRef.current.skipClick = true;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > threshold) {
          startRestTimer();
        } else if (dx < -threshold && activeExercise) {
          void handleUndoToday(activeExercise.id);
        }
      } else if (dy < -threshold) {
        void handleLogPrimary(2);
      }
    },
    [activeExercise, handleLogPrimary, handleUndoToday, startRestTimer],
  );

  const handlePointerUp = useCallback(() => {
    gestureRef.current.active = false;
    if (gestureRef.current.longPressTimer) {
      window.clearTimeout(gestureRef.current.longPressTimer);
      gestureRef.current.longPressTimer = null;
    }
  }, []);

  const handlePrimaryClick = useCallback(async () => {
    if (gestureRef.current.skipClick) {
      gestureRef.current.skipClick = false;
      return;
    }
    await handleLogPrimary();
  }, [handleLogPrimary]);

  if (loading) {
    return (
      <div className="flex min-h-screen items-center justify-center text-sm text-[color:var(--muted)]">
        Loading gym log...
      </div>
    );
  }

  const prevExercise = exercisesForWorkout[resolvedActiveIndex - 1] ?? null;
  const nextExercise = exercisesForWorkout[resolvedActiveIndex + 1] ?? null;

  const nextLabel =
    activeExercise && suggestedSet
      ? activeExercise.type === "bodyweight"
        ? `BWx${suggestedSet.reps}`
        : `${formatLb(suggestedSet.inputLb)}x${suggestedSet.reps}`
      : "--";
  const primaryLabel =
    activeExercise && suggestedSet
      ? `+ ${nextLabel}`
      : "+ Log set";

  return (
    <>
      <AppShell
        title="Log"
        mainClassName="pt-4"
        header={
          <div className="space-y-3 px-5 py-3">
            <div className="flex items-center justify-between gap-3">
              <div className="-mx-5 flex flex-1 gap-2 overflow-x-auto px-5 pb-1">
                {sessionBarDates.map((dateKey) => {
                  const isActive = dateKey === activeSessionDate;
                  const label =
                    dateKey === todayKey ? "Today" : formatDateHeading(dateKey);
                  return (
                    <button
                      key={dateKey}
                      type="button"
                      onClick={() => updateSessionDate(dateKey)}
                      className={`min-h-[36px] whitespace-nowrap rounded-full border px-3 text-[10px] uppercase tracking-[0.3em] transition ${
                        isActive
                          ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                          : "border-[var(--border)] bg-[color:var(--bg-card)] text-[color:var(--muted)]"
                      }`}
                    >
                      {label}
                    </button>
                  );
                })}
                <button
                  type="button"
                  onClick={openCalendar}
                  className="min-h-[36px] whitespace-nowrap rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
                >
                  Pick
                </button>
              </div>
              <div className="flex items-center gap-2">
                <div className="hidden min-h-[36px] items-center rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)] sm:flex">
                  Sync ✓
                </div>
                <Link
                  href="/settings"
                  className="grid h-11 w-11 place-items-center rounded-full border border-[var(--border)] bg-[color:var(--bg-card)]"
                  aria-label="Settings"
                >
                  <IconSettings className="h-4 w-4" />
                </Link>
              </div>
            </div>
            <button
              type="button"
              onClick={() => setSessionPickerOpen(true)}
              className="flex min-h-[44px] w-full items-center gap-2 rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-2 text-left"
            >
              <div className="min-w-0">
                <div className="text-[10px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                  Workout {activeWorkout} · {sessionDateLabel}
                </div>
                <div className="truncate text-sm font-semibold text-[color:var(--text)]">
                  {activeMeta?.focus ? `${activeMeta.focus} Focus` : "Session"}
                </div>
                <div className="mt-1 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                  {activeSetCount} sets · {activeCompleted}/{activeMeta?.total ?? 0} complete
                </div>
              </div>
              <IconChevronDown className="h-4 w-4 text-[color:var(--muted)]" />
            </button>
          </div>
        }
      >
        <div className="space-y-4">
          {activeExercise ? (
            <div className="flex items-center justify-center gap-4 text-[10px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
              <span className="max-w-[30%] truncate">
                {prevExercise ? `← ${prevExercise.name}` : ""}
              </span>
              <span className="max-w-[40%] truncate text-[color:var(--text)]">
                {activeExercise.name}
              </span>
              <span className="max-w-[30%] truncate text-right">
                {nextExercise ? `${nextExercise.name} →` : ""}
              </span>
            </div>
          ) : null}

          <div
            ref={carouselRef}
            onScroll={handleScroll}
            className="flex snap-x snap-mandatory overflow-x-auto scroll-smooth"
          >
            {exercisesForWorkout.map((exercise) => {
              const isActive = exercise.id === activeExercise?.id;
              const exerciseLastSet = lastSetByExercise.get(exercise.id) ?? null;
              const exerciseSuggested =
                isActive && suggestedSet
                  ? suggestedSet
                  : exerciseLastSet
                    ? {
                        inputLb: exerciseLastSet.inputLb,
                        reps: exerciseLastSet.reps,
                        recommended: false,
                      }
                    : null;
              const lastLabelLocal = exerciseLastSet
                ? formatSetLabel(exerciseLastSet, exercise)
                : "--";
              const nextLabelLocal = exerciseSuggested
                ? exercise.type === "bodyweight"
                  ? `BWx${exerciseSuggested.reps}`
                  : `${formatLb(exerciseSuggested.inputLb)}x${exerciseSuggested.reps}`
                : "--";
              const targetDelta =
                exerciseLastSet && exerciseSuggested
                  ? exerciseSuggested.inputLb - exerciseLastSet.inputLb
                  : 0;

              return (
                <div key={exercise.id} className="min-w-full snap-start px-1">
                  <div
                    className={`rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)] ${
                      isActive ? "animate-[rise-in_0.35s_ease-out]" : ""
                    }`}
                  >
                    <div className="flex flex-wrap items-center justify-between gap-4">
                      <div>
                        <div className="text-[10px] uppercase tracking-[0.4em] text-[color:var(--muted)]">
                          {typeLabel(exercise.type)} • {getModeLabel(exercise)}
                        </div>
                        <div className="mt-2 text-2xl font-semibold text-[color:var(--text)] font-serif">
                          {exercise.name}
                        </div>
                        <div className="mt-2 text-xs text-[color:var(--muted)]">
                          Last {lastLabelLocal}
                          {exerciseLastSet && exerciseSuggested ? (
                            <>
                              <span className="mx-2">·</span>
                              {targetDelta > 0
                                ? `Target +${formatLb(targetDelta)} lb`
                                : `Next ${nextLabelLocal}`}
                            </>
                          ) : null}
                        </div>
                      </div>
                    </div>

                    {isActive ? (
                      <div className="mt-6 space-y-4">
                        <button
                          type="button"
                          onClick={handlePrimaryClick}
                          onPointerDown={handlePointerDown}
                          onPointerMove={handlePointerMove}
                          onPointerUp={handlePointerUp}
                          onPointerLeave={handlePointerUp}
                          onPointerCancel={handlePointerUp}
                          className="flex min-h-[72px] w-full items-center justify-center rounded-[26px] bg-[color:var(--accent)] px-4 text-lg font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
                          style={{ touchAction: "none" }}
                          aria-label="Log set"
                        >
                          {primaryLabel}
                        </button>
                        <div className="flex flex-wrap items-center justify-between gap-3 text-xs text-[color:var(--muted)]">
                          <span>Swipe up: log x2 · Swipe left: undo</span>
                          <span>Swipe right: rest · Long press: edit</span>
                        </div>

                        {restTimerEndsAt ? (
                          <div className="flex items-center justify-between gap-3 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 py-3">
                            <div className="flex items-center gap-2 text-sm text-[color:var(--text)]">
                              <IconTimer className="h-4 w-4" />
                              Rest {Math.floor(restRemaining / 60)}:
                              {String(restRemaining % 60).padStart(2, "0")}
                            </div>
                            <button
                              type="button"
                              onClick={() => setRestTimerEndsAt(null)}
                              className="min-h-[44px] rounded-full border border-[var(--border)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
                            >
                              Stop
                            </button>
                          </div>
                        ) : null}

                        <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
                          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                            Timeline
                          </div>
                          <div className="mt-3 max-h-[220px] space-y-2 overflow-y-auto">
                            {sessionSets.length ? (
                              sessionSets.map((setEntry) => {
                                const warmup = setEntry.tags?.includes("warmup");
                                return (
                                  <div
                                    key={setEntry.id}
                                    className="flex items-center gap-3 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-card)] animate-[fade-in_0.25s_ease-out]"
                                  >
                                    <button
                                      type="button"
                                      onClick={() => setEditingSet(setEntry)}
                                      className="flex min-h-[56px] flex-1 items-center gap-3 px-4 py-2 text-left"
                                    >
                                      <span className="h-2 w-2 rounded-full bg-[color:var(--accent)]" />
                                      <div>
                                        <div className="text-sm font-semibold text-[color:var(--text)] font-mono">
                                          {formatSetLabel(setEntry, exercise)}
                                        </div>
                                        <div className="text-xs text-[color:var(--muted)]">
                                          {formatShortTime(setEntry.ts)}
                                        </div>
                                      </div>
                                      {warmup ? (
                                        <span className="ml-auto rounded-full border border-[var(--border)] bg-[color:var(--chip)] px-2 py-1 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                                          Warmup
                                        </span>
                                      ) : null}
                                    </button>
                                    <button
                                      type="button"
                                      onClick={() => handleToggleWarmup(setEntry)}
                                      className="grid h-11 w-11 place-items-center rounded-full border border-[var(--border)] text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
                                    >
                                      W
                                    </button>
                                    <button
                                      type="button"
                                      onClick={() => handleDeleteSet(setEntry)}
                                      className="grid h-11 w-11 place-items-center rounded-full border border-[var(--border)] text-[10px] uppercase tracking-[0.3em] text-[color:var(--danger)]"
                                    >
                                      Del
                                    </button>
                                  </div>
                                );
                              })
                            ) : (
                              <div className="rounded-2xl border border-dashed border-[var(--border)] p-4 text-center text-sm text-[color:var(--muted)]">
                                No sets yet. Tap to log the first.
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    ) : (
                      <div className="mt-6 text-xs text-[color:var(--muted)]">
                        Swipe here to focus this exercise.
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          {!exercisesForWorkout.length ? (
            <div className="rounded-[var(--radius-lg)] border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
              No exercises in this workout yet. Add some in Settings.
            </div>
          ) : null}
        </div>
      </AppShell>

      <BottomSheet
        open={sessionPickerOpen}
        onClose={() => setSessionPickerOpen(false)}
        title="Session picker"
      >
        <div className="space-y-3">
          {workoutMeta.map((meta) => {
            const active = meta.workout === activeWorkout;
            return (
              <button
                key={meta.workout}
                type="button"
                onClick={() => {
                  setSelectedWorkout(meta.workout);
                  setActiveIndex(0);
                  if (carouselRef.current) {
                    carouselRef.current.scrollTo({ left: 0, behavior: "auto" });
                  }
                  setSessionPickerOpen(false);
                }}
                className={`w-full rounded-2xl border px-4 py-3 text-left transition ${
                  active
                    ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                    : "border-[var(--border)] bg-[color:var(--bg-elev)] text-[color:var(--text)]"
                }`}
              >
                <div className="text-[10px] uppercase tracking-[0.35em] opacity-80">
                  Workout {meta.workout}
                </div>
                <div className="mt-2 text-sm">
                  {meta.focus ? `Focus: ${meta.focus}` : "No focus yet"}
                </div>
                <div className="mt-2 text-[10px] uppercase tracking-[0.3em] opacity-80">
                  {meta.setCount} sets · {meta.completed}/{meta.total || 0} complete
                </div>
              </button>
            );
          })}
          <Link
            href="/settings"
            onClick={() => setSessionPickerOpen(false)}
            className="block rounded-2xl border border-dashed border-[var(--border)] px-4 py-3 text-center text-xs uppercase tracking-[0.3em] text-[color:var(--muted)]"
          >
            + New workout
          </Link>
        </div>
      </BottomSheet>

      <BottomSheet
        open={calendarOpen}
        onClose={() => setCalendarOpen(false)}
        title="Pick session date"
      >
        <div className="space-y-4">
          <div className="flex items-center justify-between gap-3">
            <button
              type="button"
              onClick={handlePrevMonth}
              className="min-h-[36px] rounded-full border border-[var(--border)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
            >
              Prev
            </button>
            <div className="text-sm font-semibold text-[color:var(--text)] font-serif">
              {calendarMonthLabel}
            </div>
            <button
              type="button"
              onClick={handleNextMonth}
              className="min-h-[36px] rounded-full border border-[var(--border)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
            >
              Next
            </button>
          </div>
          <div className="grid grid-cols-7 gap-2 text-center text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
            {["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map((day) => (
              <div key={day}>{day}</div>
            ))}
          </div>
          <div className="grid grid-cols-7 gap-2">
            {calendarDays.map((day, index) => {
              if (!day) {
                return <div key={`empty-${index}`} />;
              }
              return (
                <button
                  key={day.dateKey}
                  type="button"
                  onClick={() => {
                    updateSessionDate(day.dateKey);
                    setCalendarOpen(false);
                  }}
                  className={`flex min-h-[44px] flex-col items-center justify-center rounded-2xl border px-2 py-2 text-xs font-semibold transition ${
                    day.isActive
                      ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                      : "border-[var(--border)] bg-[color:var(--bg-elev)] text-[color:var(--text)]"
                  }`}
                >
                  <span>{day.day}</span>
                  <span
                    className={`mt-1 h-1 w-1 rounded-full ${
                      day.hasWorkout
                        ? "bg-[color:var(--accent-2)]"
                        : day.isToday
                          ? "bg-[color:var(--accent)]"
                          : "bg-transparent"
                    }`}
                    aria-hidden="true"
                  />
                </button>
              );
            })}
          </div>
          <div className="text-xs text-[color:var(--muted)]">
            Dots mark days with a logged workout.
          </div>
        </div>
      </BottomSheet>

      <SetComposer
        open={composerOpen}
        exercise={activeExercise}
        settings={settings}
        seed={composerSeed}
        onClose={() => {
          setComposerOpen(false);
          setComposerSeed(null);
        }}
        onSave={(draft) => {
          if (!activeExercise) return;
          handleAddSet(activeExercise, draft);
          setComposerOpen(false);
          setComposerSeed(null);
        }}
      />

      <SetComposer
        open={Boolean(editingSet)}
        mode="edit"
        exercise={
          editingSet
            ? exerciseById.get(editingSet.exerciseId) ?? null
            : null
        }
        settings={
          editingSet
            ? { ...settings, barLb: editingSet.barLbSnapshot }
            : settings
        }
        initial={editingSet}
        onClose={() => setEditingSet(null)}
        onSave={handleEditUpdate}
        onDelete={handleEditDelete}
      />

      <Onboarding
        open={needsOnboarding}
        defaultBarLb={settings.barLb}
        onComplete={handleOnboardingComplete}
      />

      {toast ? (
        <Toast
          message={toast.message}
          actionLabel={toast.action ? "Undo" : undefined}
          onAction={() => {
            toast.action?.();
            setToast(null);
          }}
          onClose={() => setToast(null)}
        />
      ) : null}
    </>
  );
};

export default LogPage;

#### END app/page.tsx ####

#### START app/progress/page.tsx ####

"use client";

import { useEffect, useMemo, useState } from "react";
import AppShell from "../../components/AppShell";
import Chip from "../../components/Chip";
import { IconSearch } from "../../components/Icons";
import { estimateE1RM, formatKg, formatLb, toKg } from "../../lib/calc";
import { formatDateHeading } from "../../lib/date";
import { useExercises } from "../../src/hooks/useExercises";
import { useSets } from "../../src/hooks/useSets";
import { useSettings } from "../../src/hooks/useSettings";
import type { SetEntry } from "../../lib/types";

const ProgressPage = () => {
  const {
    exercises,
    error: exercisesError,
  } = useExercises();
  const { sets, error: setsError } = useSets();
  const { settings, error: settingsError } = useSettings();
  const [search, setSearch] = useState("");
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const [range, setRange] = useState<5 | 10 | 20 | "all">(10);

  useEffect(() => {
    const errors = [exercisesError, setsError, settingsError].filter(Boolean);
    if (!errors.length) return;
    console.error("Progress page data error:", errors);
  }, [exercisesError, setsError, settingsError]);

  const resolvedSelectedId = selectedId ?? exercises[0]?.id ?? null;
  const selectedExercise =
    exercises.find((exercise) => exercise.id === resolvedSelectedId) ?? null;
  const isBodyweight = selectedExercise?.type === "bodyweight";

  const exerciseSets = useMemo(() => {
    if (!selectedExercise) return [] as SetEntry[];
    return sets.filter((set) => set.exerciseId === selectedExercise.id);
  }, [sets, selectedExercise]);

  const sessionStats = useMemo(() => {
    const byDate = new Map<
      string,
      { bestTotal: number; bestE1RM: number; bestReps: number }
    >();
    exerciseSets.forEach((set) => {
      const existing = byDate.get(set.date) ?? {
        bestTotal: 0,
        bestE1RM: 0,
        bestReps: 0,
      };
      const bestTotal = Math.max(existing.bestTotal, set.totalLb);
      const e1rm = estimateE1RM(set.totalLb, set.reps, settings.e1rmFormula);
      const bestE1RM = Math.max(existing.bestE1RM, e1rm);
      const bestReps = Math.max(existing.bestReps, set.reps);
      byDate.set(set.date, { bestTotal, bestE1RM, bestReps });
    });
    return Array.from(byDate.entries()).sort((a, b) => (a[0] > b[0] ? 1 : -1));
  }, [exerciseSets, settings.e1rmFormula]);

  const rangedStats =
    range === "all" ? sessionStats : sessionStats.slice(-range);
  const chartData = rangedStats.map(([, stats]) =>
    isBodyweight ? stats.bestReps : stats.bestE1RM,
  );
  const maxValue = Math.max(...chartData, 0);
  const minValue = Math.min(...chartData, maxValue);

  const showLb = settings.unitDisplay === "both" || settings.unitDisplay === "lb";
  const showKg = settings.unitDisplay === "both" || settings.unitDisplay === "kg";

  const bestTotal = exerciseSets.reduce((max, set) => Math.max(max, set.totalLb), 0);
  const bestE1RM = exerciseSets.reduce(
    (max, set) => Math.max(max, estimateE1RM(set.totalLb, set.reps, settings.e1rmFormula)),
    0,
  );
  const bestReps = exerciseSets.reduce((max, set) => Math.max(max, set.reps), 0);

  const formatTotal = (lb: number) => {
    const kg = toKg(lb, settings.roundingKg);
    return `${showLb ? `${formatLb(lb)} lb` : ""}${
      showLb && showKg ? " | " : ""
    }${showKg ? `${formatKg(kg, settings.roundingKg)} kg` : ""}`;
  };

  const points = chartData
    .map((value, index) => {
      const x = chartData.length <= 1 ? 50 : (index / (chartData.length - 1)) * 100;
      const range = maxValue - minValue || 1;
      const y = 36 - ((value - minValue) / range) * 28;
      return `${x},${y}`;
    })
    .join(" ");

  const filteredExercises = exercises.filter((exercise) =>
    exercise.name.toLowerCase().includes(search.toLowerCase()),
  );

  const setCountByExercise = useMemo(() => {
    const map = new Map<string, number>();
    sets.forEach((set) => {
      map.set(set.exerciseId, (map.get(set.exerciseId) ?? 0) + 1);
    });
    return map;
  }, [sets]);

  return (
    <AppShell title="Progress">
      <div className="space-y-5">
        <div className="flex min-h-[56px] items-center gap-3 rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-3 shadow-[var(--shadow)]">
          <IconSearch className="h-5 w-5 text-[color:var(--muted)]" />
          <input
            value={search}
            onChange={(event) => setSearch(event.target.value)}
            placeholder="Find exercise"
            className="w-full bg-transparent text-sm text-[color:var(--text)] outline-none placeholder:text-[color:var(--muted)]"
          />
        </div>

        <div className="flex gap-2 overflow-x-auto pb-2">
          {filteredExercises.map((exercise) => {
            const count = setCountByExercise.get(exercise.id) ?? 0;
            const active = resolvedSelectedId === exercise.id;
            return (
              <button
                key={exercise.id}
                type="button"
                onClick={() => setSelectedId(exercise.id)}
                className={`min-h-[56px] min-w-[160px] rounded-2xl border border-[var(--border)] px-3 py-2 text-left transition ${
                  active
                    ? "bg-[color:var(--accent)] text-[color:var(--accent-ink)] shadow-[var(--shadow)]"
                    : "bg-[color:var(--bg-card)] text-[color:var(--text)]"
                }`}
              >
                <div className="text-[10px] uppercase tracking-[0.35em] opacity-80">
                  Exercise
                </div>
                <div className="mt-1 text-sm font-semibold">{exercise.name}</div>
                <div className="mt-1 text-[10px] uppercase tracking-[0.3em] opacity-70">
                  {count} sets
                </div>
              </button>
            );
          })}
        </div>

        {selectedExercise ? (
          <div className="space-y-4">
            <div className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
              <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                Bests + summary
              </div>
              <div className="mt-3 grid gap-3 sm:grid-cols-2">
                {isBodyweight ? (
                  <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
                    <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                      Best reps
                    </div>
                    <div className="mt-2 text-lg font-semibold text-[color:var(--text)] font-mono">
                      {bestReps || "-"}
                    </div>
                  </div>
                ) : (
                  <>
                    <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
                      <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                        Best Total
                      </div>
                      <div className="mt-2 text-base font-semibold text-[color:var(--text)] font-mono">
                        {bestTotal ? formatTotal(bestTotal) : "-"}
                      </div>
                    </div>
                    <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
                      <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                        Best e1RM
                      </div>
                      <div className="mt-2 text-base font-semibold text-[color:var(--text)] font-mono">
                        {bestE1RM ? formatTotal(bestE1RM) : "-"}
                      </div>
                    </div>
                  </>
                )}
                <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
                  <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                    Sessions
                  </div>
                  <div className="mt-2 text-lg font-semibold text-[color:var(--text)] font-mono">
                    {sessionStats.length}
                  </div>
                </div>
              </div>
            </div>

            <div className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
              <div className="flex flex-wrap items-center justify-between gap-3 text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                <span>{isBodyweight ? "Reps trend" : "e1RM trend"}</span>
                <div className="flex flex-wrap gap-2">
                  {([5, 10, 20, "all"] as const).map((value) => (
                    <Chip
                      key={value}
                      size="sm"
                      selected={range === value}
                      onClick={() => setRange(value)}
                    >
                      {value === "all" ? "ALL" : value}
                    </Chip>
                  ))}
                </div>
              </div>
              <div className="mt-4">
                {chartData.length ? (
                  <svg viewBox="0 0 100 40" className="h-32 w-full">
                    <defs>
                      <linearGradient id="trend" x1="0" x2="1" y1="0" y2="0">
                        <stop offset="0%" stopColor="var(--accent-2)" />
                        <stop offset="100%" stopColor="var(--accent)" />
                      </linearGradient>
                    </defs>
                    <polyline
                      fill="none"
                      stroke="url(#trend)"
                      strokeWidth="2"
                      points={points}
                    />
                    <circle
                      cx={points.split(" ").slice(-1)[0]?.split(",")[0] ?? 0}
                      cy={points.split(" ").slice(-1)[0]?.split(",")[1] ?? 0}
                      r="2"
                      fill="var(--accent)"
                    />
                  </svg>
                ) : (
                  <div className="rounded-2xl border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
                    Log sets to see trend data.
                  </div>
                )}
              </div>
            </div>

            <div className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
              <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                Recent sessions
              </div>
              <div className="mt-4 space-y-2">
                {rangedStats.length ? (
                  [...rangedStats].reverse().map(([date, stats]) => (
                    <div
                      key={date}
                      className="flex items-center justify-between rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 py-3 text-sm"
                    >
                      <div>
                        <div className="text-sm font-semibold text-[color:var(--text)]">
                          {formatDateHeading(date)}
                        </div>
                        <div className="text-xs text-[color:var(--muted)]">
                          {isBodyweight
                            ? `Best reps ${stats.bestReps}`
                            : `Best total ${formatTotal(stats.bestTotal)}`}
                        </div>
                      </div>
                      <div className="text-right text-xs text-[color:var(--muted)] font-mono">
                        {isBodyweight
                          ? `${stats.bestReps} reps`
                          : `e1RM ${formatTotal(stats.bestE1RM)}`}
                      </div>
                    </div>
                  ))
                ) : (
                  <div className="rounded-2xl border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
                    No sessions yet.
                  </div>
                )}
              </div>
            </div>
          </div>
        ) : (
          <div className="rounded-[var(--radius-lg)] border border-dashed border-[var(--border)] p-6 text-center text-sm text-[color:var(--muted)]">
            Add an exercise to start tracking progress.
          </div>
        )}
      </div>
    </AppShell>
  );
};

export default ProgressPage;

#### END app/progress/page.tsx ####

#### START app/settings/page.tsx ####

"use client";

import { useEffect, useRef, useState } from "react";
import AppShell from "../../components/AppShell";
import Chip from "../../components/Chip";
import Stepper from "../../components/Stepper";
import Toast from "../../components/Toast";
import {
  IconDrag,
  IconDownload,
  IconSearch,
  IconTrash,
  IconUpload,
} from "../../components/Icons";
import { useExercises } from "../../src/hooks/useExercises";
import { useSessions } from "../../src/hooks/useSessions";
import { useSets } from "../../src/hooks/useSets";
import { useSettings } from "../../src/hooks/useSettings";
import { computeTotals } from "../../lib/calc";
import { formatShortTime, getLocalDateKey } from "../../lib/date";
import {
  DEFAULT_REP_PRESETS,
  DEFAULT_WEIGHT_PRESETS,
} from "../../lib/defaults";
import {
  parseBackup,
  parseSetsCsv,
  serializeBackup,
  serializeSetsCsv,
} from "../../lib/backup";
import {
  disableFileMirror,
  enableFileMirror,
  getFileMirrorState,
  writeFileMirrorNow,
  type FileMirrorState,
} from "../../lib/fileMirror";
import type {
  Exercise,
  ExerciseType,
  WorkoutId,
} from "../../lib/types";

type BeforeInstallPromptEvent = Event & {
  prompt: () => Promise<void>;
  userChoice: Promise<{ outcome: "accepted" | "dismissed" }>;
};

type ExerciseTemplate = {
  name: string;
  type: ExerciseType;
  perSide?: boolean;
};

const workoutTabs: WorkoutId[] = ["A", "B", "Custom"];
const typeOptions: ExerciseType[] = [
  "barbell",
  "dumbbell",
  "machine",
  "bodyweight",
];

const EXERCISE_LIBRARY: ExerciseTemplate[] = [
  { name: "Bench Press", type: "barbell", perSide: true },
  { name: "Squat", type: "barbell", perSide: true },
  { name: "Deadlift", type: "barbell", perSide: true },
  { name: "Overhead Press", type: "barbell", perSide: true },
  { name: "Barbell Row", type: "barbell", perSide: true },
  { name: "Dumbbell Row", type: "dumbbell", perSide: true },
  { name: "Cable Row", type: "machine" },
  { name: "Machine Row", type: "machine" },
  { name: "Lat Pulldown", type: "machine" },
  { name: "Leg Press", type: "machine" },
  { name: "Leg Extension", type: "machine" },
  { name: "Chest Press", type: "machine" },
  { name: "Incline Bench", type: "barbell", perSide: true },
  { name: "Dips", type: "bodyweight" },
  { name: "Pull Up", type: "bodyweight" },
  { name: "Push Up", type: "bodyweight" },
];

const getNow = () => Date.now();

const SettingsPage = () => {
  const {
    settings,
    error: settingsError,
    updateSettings,
    replaceSettings,
  } = useSettings();
  const {
    exercises,
    error: exercisesError,
    saveExercise,
    saveExercises,
    deleteExercise,
  } = useExercises();
  const { sets, error: setsError, addSet } = useSets();
  const { sessions, error: sessionsError, saveSessions } = useSessions();
  const [toast, setToast] = useState<string | null>(null);
  const toastTimer = useRef<number | null>(null);
  const [installPrompt, setInstallPrompt] = useState<BeforeInstallPromptEvent | null>(
    null,
  );
  const [mirrorState, setMirrorState] = useState<FileMirrorState>({
    supported: false,
    enabled: false,
    fileName: null,
    lastWrite: null,
  });
  const [mirrorBusy, setMirrorBusy] = useState(false);

  const [activeWorkout, setActiveWorkout] = useState<WorkoutId>("A");
  const [searchTerm, setSearchTerm] = useState("");
  const [dragId, setDragId] = useState<string | null>(null);

  useEffect(() => {
    const load = async () => {
      const mirrorData = await getFileMirrorState();
      setMirrorState(mirrorData);
    };
    load();
  }, []);

  useEffect(() => {
    const handler = (event: Event) => {
      event.preventDefault();
      setInstallPrompt(event as BeforeInstallPromptEvent);
    };
    window.addEventListener("beforeinstallprompt", handler);
    return () => window.removeEventListener("beforeinstallprompt", handler);
  }, []);

  useEffect(() => {
    return () => {
      if (toastTimer.current) {
        window.clearTimeout(toastTimer.current);
      }
    };
  }, []);

  useEffect(() => {
    const errors = [settingsError, exercisesError, setsError, sessionsError].filter(
      Boolean,
    );
    if (!errors.length) return;
    console.error("Settings page data error:", errors);
  }, [settingsError, exercisesError, setsError, sessionsError]);

  const showToast = (message: string) => {
    setToast(message);
    if (toastTimer.current) {
      window.clearTimeout(toastTimer.current);
    }
    toastTimer.current = window.setTimeout(() => setToast(null), 3000);
  };

  const refreshMirrorState = async () => {
    const next = await getFileMirrorState();
    setMirrorState(next);
    return next;
  };

  const handleEnableMirror = async () => {
    if (mirrorBusy) return;
    setMirrorBusy(true);
    const result = await enableFileMirror();
    if (!result.ok) {
      if (result.reason === "unsupported") {
        showToast("File mirror requires Chrome.");
      } else if (result.reason === "permission") {
        showToast("File permission denied.");
      } else if (result.reason !== "cancelled") {
        showToast("Could not enable file mirror.");
      }
      await refreshMirrorState();
      setMirrorBusy(false);
      return;
    }
    const writeResult = await writeFileMirrorNow();
    if (!writeResult.ok) {
      showToast("File mirror enabled, but write failed.");
    } else {
      showToast("File mirror enabled.");
    }
    await refreshMirrorState();
    setMirrorBusy(false);
  };

  const handleWriteMirror = async () => {
    if (mirrorBusy) return;
    setMirrorBusy(true);
    const result = await writeFileMirrorNow();
    if (!result.ok) {
      if (result.reason === "unsupported") {
        showToast("File mirror requires Chrome.");
      } else if (result.reason === "permission") {
        showToast("File permission denied.");
      } else if (result.reason === "not-enabled") {
        showToast("File mirror not enabled.");
      } else {
        showToast("Could not write mirror file.");
      }
    } else {
      showToast("Mirror updated.");
    }
    await refreshMirrorState();
    setMirrorBusy(false);
  };

  const handleDisableMirror = async () => {
    if (mirrorBusy) return;
    setMirrorBusy(true);
    await disableFileMirror();
    await refreshMirrorState();
    showToast("File mirror disabled.");
    setMirrorBusy(false);
  };

  const handleExerciseUpdate = async (id: string, updates: Partial<Exercise>) => {
    const exercise = exercises.find((item) => item.id === id);
    if (!exercise) return;
    let updated: Exercise = { ...exercise, ...updates };
    if (updates.type) {
      if (updates.type === "barbell" || updates.type === "dumbbell") {
        if (updated.perSide === undefined) updated.perSide = true;
      } else {
        updated.perSide = false;
      }
    }
    if (updates.workout && updates.workout !== exercise.workout) {
      const nextOrder = exercises.filter(
        (item) => item.workout === updates.workout,
      ).length;
      updated = { ...updated, order: nextOrder };
    }
    await saveExercise(updated);
  };

  const handleAddExercise = async (
    name: string,
    type: ExerciseType,
    perSide?: boolean,
  ) => {
    const workoutList = exercises
      .filter((exercise) => exercise.workout === activeWorkout)
      .sort((a, b) => a.order - b.order);
    const newExercise: Exercise = {
      id: crypto.randomUUID(),
      name: name.trim(),
      type,
      workout: activeWorkout,
      perSide:
        perSide ?? (type === "barbell" || type === "dumbbell" ? true : false),
      order: workoutList.length,
      createdAt: getNow(),
    };
    await saveExercise(newExercise);
    setSearchTerm("");
  };

  const handleRemoveExercise = async (exercise: Exercise) => {
    await deleteExercise(exercise.id);
    showToast("Exercise removed. Existing sets keep history.");
  };

  const handleDragStart = (id: string) => {
    setDragId(id);
  };

  const handleDrop = async (workout: WorkoutId, targetId: string) => {
    if (!dragId || dragId === targetId) return;
    const workoutList = exercises
      .filter((exercise) => exercise.workout === workout)
      .sort((a, b) => a.order - b.order);
    const fromIndex = workoutList.findIndex((item) => item.id === dragId);
    const toIndex = workoutList.findIndex((item) => item.id === targetId);
    if (fromIndex === -1 || toIndex === -1) return;
    const updated = [...workoutList];
    const [moved] = updated.splice(fromIndex, 1);
    updated.splice(toIndex, 0, moved);
    const reordered = exercises.map((exercise) => {
      if (exercise.workout !== workout) return exercise;
      const newIndex = updated.findIndex((item) => item.id === exercise.id);
      return { ...exercise, order: newIndex };
    });
    await saveExercises(reordered);
    setDragId(null);
  };

  const downloadFile = (content: string, fileName: string, type: string) => {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = fileName;
    anchor.click();
    URL.revokeObjectURL(url);
  };

  const handleExportJson = async () => {
    const payload = serializeBackup(exercises, sets, settings, sessions);
    downloadFile(payload, "gymlog-backup.json", "application/json");
  };

  const handleExportCsv = async () => {
    const payload = serializeSetsCsv(sets, exercises);
    downloadFile(payload, "gymlog-sets.csv", "text/csv");
  };

  const handleImportFile = async (file: File) => {
    try {
      const text = await file.text();
      if (file.name.endsWith(".json")) {
        const payload = parseBackup(text);
        const existingById = new Map(
          exercises.map((exercise) => [exercise.id, exercise]),
        );
        const mergedExercises = [...exercises];
        payload.exercises.forEach((exercise) => {
          if (!existingById.has(exercise.id)) {
            mergedExercises.push(exercise);
          }
        });
        await saveExercises(mergedExercises);
        for (const setEntry of payload.sets) {
          await addSet(setEntry);
        }
        if (payload.sessions?.length) {
          await saveSessions(payload.sessions);
        }
        await replaceSettings({ ...settings, ...payload.settings, onboarded: true });
        showToast("Backup imported.");
        return;
      }

      const rows = parseSetsCsv(text);
      if (!rows.length) {
        showToast("No rows found in CSV.");
        return;
      }
      const byName = new Map(
        exercises.map((exercise) => [exercise.name.toLowerCase(), exercise]),
      );
      let nextExercises = [...exercises];

      for (const row of rows) {
        const name = row.exercise?.trim();
        if (!name) continue;
        let exercise = byName.get(name.toLowerCase());
        if (!exercise) {
          const workoutList = nextExercises
            .filter((item) => item.workout === "Custom")
            .sort((a, b) => a.order - b.order);
          exercise = {
            id: crypto.randomUUID(),
            name,
            type: (row.type as ExerciseType) || "machine",
            workout: "Custom",
            perSide:
              row.type === "barbell" || row.type === "dumbbell" ? true : false,
            order: workoutList.length,
            createdAt: getNow(),
          };
          nextExercises = [...nextExercises, exercise];
          byName.set(name.toLowerCase(), exercise);
        }

        const ts = row.ts ?? getNow();
        const barLbSnapshot = row.barLbSnapshot || settings.barLb;
        const perSide =
          exercise.type === "barbell" || exercise.type === "dumbbell"
            ? exercise.perSide ?? true
            : false;
        const totals = row.totalLb
          ? { totalLb: row.totalLb, totalKg: row.totalKg }
          : computeTotals(
              row.inputLb,
              exercise.type,
              barLbSnapshot,
              settings.roundingKg,
              perSide,
            );

        const setEntry = {
          id: crypto.randomUUID(),
          ts,
          date: row.date || getLocalDateKey(ts),
          exerciseId: exercise.id,
          reps: row.reps,
          inputLb: row.inputLb,
          barLbSnapshot,
          totalLb: totals.totalLb,
          totalKg: totals.totalKg,
          note: row.note || undefined,
          tags: row.tags?.length ? row.tags : undefined,
          meta: row.rpe ? { rpe: row.rpe } : undefined,
        };

        await addSet(setEntry);
      }

      await saveExercises(nextExercises);
      showToast("CSV imported.");
    } catch (error) {
      console.error(error);
      showToast("Import failed.");
    }
  };

  const groupedExercises = (workout: WorkoutId) =>
    exercises
      .filter((exercise) => exercise.workout === workout)
      .sort((a, b) => a.order - b.order);

  const mirrorLastWriteLabel = mirrorState.lastWrite
    ? formatShortTime(mirrorState.lastWrite)
    : "Not yet";
  const mirrorFileName = mirrorState.fileName ?? "gym-log.json";

  const normalizedTerm = searchTerm.trim().toLowerCase();
  const suggestions = normalizedTerm
    ? EXERCISE_LIBRARY.filter((item) =>
        item.name.toLowerCase().includes(normalizedTerm),
      ).slice(0, 6)
    : [];
  const hasExactMatch = suggestions.some(
    (item) => item.name.toLowerCase() === normalizedTerm,
  );

  return (
    <AppShell title="Settings">
      <div className="space-y-5">
        <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Workout builder
          </div>
          <div className="mt-4 space-y-4">
            <div className="flex flex-wrap gap-2">
              {workoutTabs.map((workout) => {
                const label = workout === "Custom" ? "+ Add" : workout;
                const active = workout === activeWorkout;
                return (
                  <button
                    key={workout}
                    type="button"
                    onClick={() => setActiveWorkout(workout)}
                    className={`min-h-[44px] rounded-full border px-4 text-xs uppercase tracking-[0.3em] transition ${
                      active
                        ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                        : "border-[var(--border)] bg-transparent text-[color:var(--muted)]"
                    }`}
                  >
                    {label}
                  </button>
                );
              })}
            </div>

            <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
              <div className="flex min-h-[48px] items-center gap-3">
                <IconSearch className="h-4 w-4 text-[color:var(--muted)]" />
                <input
                  value={searchTerm}
                  onChange={(event) => setSearchTerm(event.target.value)}
                  placeholder="Search or add exercise..."
                  className="w-full bg-transparent text-sm text-[color:var(--text)] outline-none placeholder:text-[color:var(--muted)]"
                />
              </div>
              {normalizedTerm ? (
                <div className="mt-3 space-y-2">
                  {suggestions.map((item) => (
                    <button
                      key={item.name}
                      type="button"
                      onClick={() =>
                        handleAddExercise(item.name, item.type, item.perSide)
                      }
                      className="flex min-h-[44px] w-full items-center justify-between rounded-xl border border-[var(--border)] bg-[color:var(--bg-card)] px-3 text-sm"
                    >
                      <span className="text-[color:var(--text)]">{item.name}</span>
                      <span className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                        {item.type}
                      </span>
                    </button>
                  ))}
                  {!hasExactMatch ? (
                    <button
                      type="button"
                      onClick={() => handleAddExercise(searchTerm, "barbell", true)}
                      className="min-h-[44px] w-full rounded-xl border border-dashed border-[var(--border)] px-3 text-xs uppercase tracking-[0.3em] text-[color:var(--muted)]"
                    >
                      Add &quot;{searchTerm}&quot;
                    </button>
                  ) : null}
                </div>
              ) : (
                <div className="mt-3 text-xs text-[color:var(--muted)]">
                  Type to add. Suggestions appear instantly.
                </div>
              )}
            </div>

            <div className="space-y-2">
              {groupedExercises(activeWorkout).map((exercise) => {
                const showPerSide =
                  exercise.type === "barbell" || exercise.type === "dumbbell";
                const perSideLabel =
                  exercise.type === "dumbbell" ? "Per dumbbell" : "Per side";
                return (
                  <div
                    key={exercise.id}
                    onDragOver={(event) => event.preventDefault()}
                    onDrop={() => handleDrop(activeWorkout, exercise.id)}
                    className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-3"
                  >
                    <div className="flex flex-wrap items-center gap-3">
                      <div
                        draggable
                        onDragStart={() => handleDragStart(exercise.id)}
                        className="grid h-10 w-10 cursor-grab place-items-center rounded-full border border-[var(--border)] text-[color:var(--muted)]"
                        aria-label="Drag to reorder"
                      >
                        <IconDrag className="h-4 w-4" />
                      </div>
                      <input
                        defaultValue={exercise.name}
                        onBlur={(event) =>
                          handleExerciseUpdate(exercise.id, {
                            name: event.target.value,
                          })
                        }
                        className="min-h-[44px] flex-1 bg-transparent text-sm text-[color:var(--text)] outline-none"
                      />
                      <button
                        type="button"
                        onClick={() => handleRemoveExercise(exercise)}
                        className="grid h-10 w-10 place-items-center rounded-full border border-[var(--border)] text-[color:var(--danger)]"
                        aria-label="Remove exercise"
                      >
                        <IconTrash className="h-4 w-4" />
                      </button>
                    </div>
                    <div className="mt-2 flex flex-wrap gap-2">
                      <select
                        value={exercise.type}
                        onChange={(event) =>
                          handleExerciseUpdate(exercise.id, {
                            type: event.target.value as ExerciseType,
                          })
                        }
                        className="min-h-[44px] rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--text)]"
                      >
                        {typeOptions.map((type) => (
                          <option key={type} value={type}>
                            {type}
                          </option>
                        ))}
                      </select>
                      {showPerSide ? (
                        <button
                          type="button"
                          onClick={() =>
                            handleExerciseUpdate(exercise.id, {
                              perSide: !(exercise.perSide ?? true),
                            })
                          }
                          className={`min-h-[44px] rounded-full border px-4 text-[10px] uppercase tracking-[0.3em] ${
                            exercise.perSide ?? true
                              ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                              : "border-[var(--border)] bg-transparent text-[color:var(--muted)]"
                          }`}
                        >
                          {perSideLabel}
                        </button>
                      ) : null}
                    </div>
                  </div>
                );
              })}
              {!groupedExercises(activeWorkout).length ? (
                <div className="rounded-2xl border border-dashed border-[var(--border)] p-4 text-center text-sm text-[color:var(--muted)]">
                  No exercises yet. Add one above.
                </div>
              ) : null}
            </div>
          </div>
        </section>

        <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Storage
          </div>
          <div className="mt-4 space-y-3">
            <div className="flex items-center justify-between rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 py-3 text-sm">
              <span className="text-[color:var(--text)]">Local autosave</span>
              <span className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--success)]">
                ✓
              </span>
            </div>
            <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-4 py-3 text-sm">
              <div className="flex items-center justify-between">
                <span className="text-[color:var(--text)]">Mirror file</span>
                <span className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                  {mirrorState.enabled ? "Enabled" : "Off"}
                </span>
              </div>
              <div className="mt-2 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                Last write: {mirrorLastWriteLabel}
              </div>
              <div className="mt-3 flex flex-wrap gap-2">
                {!mirrorState.enabled ? (
                  <button
                    type="button"
                    onClick={handleEnableMirror}
                    disabled={mirrorBusy}
                    className="min-h-[44px] rounded-full border border-[var(--border)] px-4 text-xs uppercase tracking-[0.3em] text-[color:var(--text)] disabled:opacity-60"
                  >
                    Enable
                  </button>
                ) : (
                  <>
                    <button
                      type="button"
                      onClick={handleWriteMirror}
                      disabled={mirrorBusy}
                      className="min-h-[44px] rounded-full border border-[var(--border)] px-4 text-xs uppercase tracking-[0.3em] text-[color:var(--text)] disabled:opacity-60"
                    >
                      Write now
                    </button>
                    <button
                      type="button"
                      onClick={handleDisableMirror}
                      disabled={mirrorBusy}
                      className="min-h-[44px] rounded-full border border-[var(--border)] px-4 text-xs uppercase tracking-[0.3em] text-[color:var(--danger)] disabled:opacity-60"
                    >
                      Disable
                    </button>
                  </>
                )}
              </div>
              <div className="mt-3 text-xs text-[color:var(--muted)]">
                Mirroring to: {mirrorFileName}
              </div>
            </div>
          </div>
        </section>

        <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Quick setup
          </div>
          <div className="mt-4 grid gap-5">
            <div>
              <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                Bar weight
              </div>
              <div className="mt-3">
                <Stepper
                  value={settings.barLb}
                  onChange={(value) => updateSettings({ barLb: value })}
                  step={5}
                  min={10}
                  max={70}
                  label="Default bar (lb)"
                />
              </div>
            </div>
            <div>
              <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                Units
              </div>
              <div className="mt-2 flex flex-wrap gap-2">
                {(["both", "lb", "kg"] as const).map((unit) => (
                  <Chip
                    key={unit}
                    selected={settings.unitDisplay === unit}
                    onClick={() => updateSettings({ unitDisplay: unit })}
                  >
                    {unit.toUpperCase()}
                  </Chip>
                ))}
              </div>
              <div className="mt-4">
                <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                  KG rounding
                </div>
                <div className="mt-2 flex flex-wrap gap-2">
                  {[0.1, 0.5, 1].map((value) => (
                    <Chip
                      key={value}
                      selected={Math.abs(settings.roundingKg - value) < 0.01}
                      onClick={() => updateSettings({ roundingKg: value })}
                    >
                      {value}kg
                    </Chip>
                  ))}
                </div>
              </div>
              <div className="mt-4">
                <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                  e1RM formula
                </div>
                <div className="mt-2 flex flex-wrap gap-2">
                  {(["epley", "brzycki"] as const).map((formula) => (
                    <Chip
                      key={formula}
                      selected={settings.e1rmFormula === formula}
                      onClick={() => updateSettings({ e1rmFormula: formula })}
                    >
                      {formula}
                    </Chip>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </section>

        <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Presets
          </div>
          <div className="mt-3">
            <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
              Weight presets
            </div>
            <div className="mt-2 flex flex-wrap gap-2">
              {settings.weightPresets.map((value) => (
                <Chip
                  key={value}
                  onClick={() =>
                    updateSettings({
                      weightPresets: settings.weightPresets.filter(
                        (item) => item !== value,
                      ),
                    })
                  }
                >
                  {value}
                </Chip>
              ))}
            </div>
            <div className="mt-3 flex gap-2">
              <input
                type="number"
                min={0}
                placeholder="Add"
                className="min-h-[44px] w-full rounded-xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-3 py-2 text-sm text-[color:var(--text)]"
                onKeyDown={(event) => {
                  if (event.key !== "Enter") return;
                  const value = Number((event.target as HTMLInputElement).value);
                  if (!Number.isNaN(value)) {
                    updateSettings({
                      weightPresets: Array.from(
                        new Set([...settings.weightPresets, value]),
                      ).sort((a, b) => a - b),
                    });
                    (event.target as HTMLInputElement).value = "";
                  }
                }}
              />
              <button
                type="button"
                onClick={() => updateSettings({ weightPresets: DEFAULT_WEIGHT_PRESETS })}
                className="min-h-[44px] rounded-xl border border-[var(--border)] px-3 py-2 text-xs uppercase tracking-[0.3em] text-[color:var(--muted)]"
              >
                Reset
              </button>
            </div>
          </div>
          <div className="mt-4">
            <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
              Rep presets
            </div>
            <div className="mt-2 flex flex-wrap gap-2">
              {settings.repPresets.map((value) => (
                <Chip
                  key={value}
                  onClick={() =>
                    updateSettings({
                      repPresets: settings.repPresets.filter((item) => item !== value),
                    })
                  }
                >
                  {value}
                </Chip>
              ))}
            </div>
            <div className="mt-3 flex gap-2">
              <input
                type="number"
                min={1}
                placeholder="Add"
                className="min-h-[44px] w-full rounded-xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-3 py-2 text-sm text-[color:var(--text)]"
                onKeyDown={(event) => {
                  if (event.key !== "Enter") return;
                  const value = Number((event.target as HTMLInputElement).value);
                  if (!Number.isNaN(value)) {
                    updateSettings({
                      repPresets: Array.from(
                        new Set([...settings.repPresets, value]),
                      ).sort((a, b) => a - b),
                    });
                    (event.target as HTMLInputElement).value = "";
                  }
                }}
              />
              <button
                type="button"
                onClick={() => updateSettings({ repPresets: DEFAULT_REP_PRESETS })}
                className="min-h-[44px] rounded-xl border border-[var(--border)] px-3 py-2 text-xs uppercase tracking-[0.3em] text-[color:var(--muted)]"
              >
                Reset
              </button>
            </div>
          </div>
        </section>

        <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Backup
          </div>
          <div className="mt-4 flex flex-wrap gap-3">
            <button
              type="button"
              onClick={handleExportJson}
              className="min-h-[44px] flex items-center gap-2 rounded-xl border border-[var(--border)] px-3 py-2 text-xs uppercase tracking-[0.3em] text-[color:var(--text)]"
            >
              <IconDownload className="h-4 w-4" />
              Export backup
            </button>
            <button
              type="button"
              onClick={handleExportCsv}
              className="min-h-[44px] flex items-center gap-2 rounded-xl border border-[var(--border)] px-3 py-2 text-xs uppercase tracking-[0.3em] text-[color:var(--text)]"
            >
              <IconDownload className="h-4 w-4" />
              Export CSV
            </button>
            <label className="min-h-[44px] flex cursor-pointer items-center gap-2 rounded-xl border border-[var(--border)] px-3 py-2 text-xs uppercase tracking-[0.3em] text-[color:var(--text)]">
              <IconUpload className="h-4 w-4" />
              Import
              <input
                type="file"
                accept=".json,.csv"
                className="hidden"
                onChange={(event) => {
                  const file = event.target.files?.[0];
                  if (file) {
                    handleImportFile(file);
                    event.target.value = "";
                  }
                }}
              />
            </label>
          </div>
        </section>

        {installPrompt ? (
          <section className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-5 shadow-[var(--shadow)]">
            <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
              Install
            </div>
            <button
              type="button"
              onClick={async () => {
                await installPrompt.prompt();
                await installPrompt.userChoice;
                setInstallPrompt(null);
              }}
              className="mt-3 min-h-[44px] w-full rounded-xl bg-[color:var(--accent)] px-3 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-[color:var(--accent-ink)]"
            >
              Install app
            </button>
          </section>
        ) : null}
      </div>

      {toast ? <Toast message={toast} onClose={() => setToast(null)} /> : null}
    </AppShell>
  );
};

export default SettingsPage;

#### END app/settings/page.tsx ####

#### START components/AppShell.tsx ####

"use client";

import type { ReactNode } from "react";
import FileMirrorSync from "./FileMirrorSync";
import TabBar from "./TabBar";

type AppShellProps = {
  title: string;
  children: ReactNode;
  headerLeft?: ReactNode;
  headerRight?: ReactNode;
  header?: ReactNode;
  mainClassName?: string;
};

const AppShell = ({
  title,
  children,
  headerLeft,
  headerRight,
  header,
  mainClassName,
}: AppShellProps) => {
  return (
    <div className="min-h-screen pb-28">
      <FileMirrorSync />
      <header className="sticky top-0 z-30 border-b border-[var(--border)] bg-[color:var(--bg-elev)] backdrop-blur-xl">
        <div className="mx-auto w-full max-w-3xl">
          {header ?? (
            <div className="flex items-center justify-between gap-3 px-5 py-4">
              <div className="flex min-w-[72px] items-center gap-2 text-[11px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
                {headerLeft}
              </div>
              <div className="text-center">
                <div className="text-[10px] uppercase tracking-[0.4em] text-[color:var(--muted)]">
                  Gym Log
                </div>
                <h1 className="mt-1 text-base font-semibold uppercase tracking-[0.2em] text-[color:var(--text)] font-serif">
                  {title}
                </h1>
              </div>
              <div className="flex min-w-[72px] items-center justify-end gap-2">
                {headerRight}
              </div>
            </div>
          )}
        </div>
      </header>
      <main
        className={`mx-auto w-full max-w-3xl px-5 pb-[calc(7rem+env(safe-area-inset-bottom))] pt-6 ${
          mainClassName ?? ""
        }`}
      >
        {children}
      </main>
      <TabBar />
    </div>
  );
};

export default AppShell;

#### END components/AppShell.tsx ####

#### START components/BottomSheet.tsx ####

"use client";

import type { ReactNode } from "react";
import { useEffect } from "react";
import { IconClose } from "./Icons";

type BottomSheetProps = {
  open: boolean;
  title: string;
  onClose: () => void;
  children: ReactNode;
  footer?: ReactNode;
};

const BottomSheet = ({ open, title, onClose, children, footer }: BottomSheetProps) => {
  useEffect(() => {
    if (!open) return undefined;
    const handleKey = (event: KeyboardEvent) => {
      if (event.key === "Escape") onClose();
    };
    document.addEventListener("keydown", handleKey);
    document.body.style.overflow = "hidden";
    return () => {
      document.removeEventListener("keydown", handleKey);
      document.body.style.overflow = "";
    };
  }, [open, onClose]);

  return (
    <div
      className={`fixed inset-0 z-50 transition ${
        open ? "pointer-events-auto" : "pointer-events-none"
      }`}
      aria-hidden={!open}
    >
      <div
        className={`absolute inset-0 bg-black/40 transition-opacity ${
          open ? "opacity-100" : "opacity-0"
        }`}
        onClick={onClose}
      />
      <div
        className={`absolute bottom-0 left-0 right-0 mx-auto w-full max-w-3xl transform transition-transform ${
          open ? "translate-y-0" : "translate-y-full"
        }`}
      >
        <div className="rounded-t-[28px] border border-[var(--border)] bg-[color:var(--bg-card)] shadow-[var(--shadow)]">
          <div className="flex justify-center pt-3">
            <div className="h-1 w-12 rounded-full bg-[color:var(--border)]" />
          </div>
          <div className="flex items-center justify-between border-b border-[var(--border)] px-5 py-4">
            <h2 className="text-sm font-semibold uppercase tracking-[0.25em] text-[color:var(--text)] font-serif">
              {title}
            </h2>
            <button
              type="button"
              onClick={onClose}
              className="grid h-11 w-11 place-items-center rounded-full border border-[var(--border)] bg-[color:var(--chip)] text-[color:var(--text)]"
            >
              <IconClose className="h-4 w-4" />
            </button>
          </div>
          <div className="max-h-[70vh] overflow-y-auto px-5 pb-6 pt-4">
            {children}
          </div>
          {footer ? (
            <div className="sticky bottom-0 border-t border-[var(--border)] bg-[color:var(--bg-elev)] px-5 py-4 backdrop-blur">
              {footer}
            </div>
          ) : null}
        </div>
      </div>
    </div>
  );
};

export default BottomSheet;

#### END components/BottomSheet.tsx ####

#### START components/Chip.tsx ####

import type { ButtonHTMLAttributes } from "react";

const sizeClasses = {
  sm: "min-h-[44px] px-3 text-xs",
  md: "min-h-[44px] px-4 text-sm",
  lg: "min-h-[48px] px-5 text-base",
};

type ChipProps = ButtonHTMLAttributes<HTMLButtonElement> & {
  selected?: boolean;
  size?: keyof typeof sizeClasses;
};

const Chip = ({
  selected = false,
  size = "md",
  className = "",
  ...props
}: ChipProps) => (
  <button
    type="button"
    className={`inline-flex min-w-[48px] items-center justify-center rounded-full border border-[var(--border)] leading-none ${
      sizeClasses[size]
    } ${
      selected
        ? "bg-[color:var(--accent)] text-[color:var(--accent-ink)] shadow-[var(--shadow)]"
        : "bg-[color:var(--chip)] text-[color:var(--text)]"
    } transition ${className}`}
    {...props}
  />
);

export default Chip;

#### END components/Chip.tsx ####

#### START components/ExerciseCard.tsx ####

import type { Exercise, SetEntry, SettingsState } from "../lib/types";
import { formatKg, formatLb, toKg } from "../lib/calc";
import { formatShortTime } from "../lib/date";

const typeLabel = (type: Exercise["type"]) => {
  switch (type) {
    case "barbell":
      return "Barbell";
    case "dumbbell":
      return "Dumbbell";
    case "machine":
      return "Machine";
    case "bodyweight":
      return "Bodyweight";
    default:
      return type;
  }
};

type ExerciseCardProps = {
  exercise: Exercise;
  lastSet?: SetEntry | null;
  todaySets: SetEntry[];
  settings: SettingsState;
  onAddSet: () => void;
  onSame: () => void;
  onSameDouble: () => void;
  onUndoLast: () => void;
  onEditSet: (set: SetEntry) => void;
  highlightSetId?: string | null;
};

const ExerciseCard = ({
  exercise,
  lastSet,
  todaySets,
  settings,
  onAddSet,
  onSame,
  onSameDouble,
  onUndoLast,
  onEditSet,
  highlightSetId,
}: ExerciseCardProps) => {
  const unitDisplay = settings.unitDisplay;
  const showLb = unitDisplay === "both" || unitDisplay === "lb";
  const showKg = unitDisplay === "both" || unitDisplay === "kg";
  const isBodyweight = exercise.type === "bodyweight";
  const isDumbbell = exercise.type === "dumbbell";
  const isBarbell = exercise.type === "barbell";

  const lastLabel = lastSet
    ? isBodyweight
      ? `BWx${lastSet.reps}`
      : `${formatLb(lastSet.inputLb)}x${lastSet.reps}`
    : null;

  const weightStep = isBarbell ? 2.5 : 5;
  const targetLabel =
    lastSet && !isBodyweight
      ? `${formatLb(lastSet.inputLb + weightStep)}x${lastSet.reps}`
      : lastSet
        ? `BWx${lastSet.reps + 1}`
        : null;

  const lastTime = todaySets[0] ? formatShortTime(todaySets[0].ts) : null;

  return (
    <div className="rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-card)] p-4 shadow-[var(--shadow)]">
      <div className="flex items-start justify-between gap-4">
        <div className="min-w-0">
          <div className="text-[10px] uppercase tracking-[0.4em] text-[color:var(--muted)] font-mono">
            {typeLabel(exercise.type)}
          </div>
          <div className="mt-1 text-lg font-semibold text-[color:var(--text)] font-serif">
            {exercise.name}
          </div>
          {lastSet && !isBodyweight ? (
            <div className="mt-1 text-[11px] text-[color:var(--muted)]">
              {isBarbell
                ? `Per side ${formatLb(lastSet.inputLb)} lb`
                : isDumbbell
                  ? `Per dumbbell ${formatLb(lastSet.inputLb)} lb`
                  : `Weight ${formatLb(lastSet.inputLb)} lb`}
              {isBarbell ? ` · Bar ${lastSet.barLbSnapshot} lb` : ""}
            </div>
          ) : null}
        </div>
        <div className="text-right">
          <div className="text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
            Last
          </div>
          <div className="mt-1 text-base font-semibold text-[color:var(--text)] font-mono">
            {lastLabel ?? "--"}
          </div>
          {lastSet ? (
            !isBodyweight ? (
              <div className="text-[11px] text-[color:var(--muted)] font-mono">
                {showLb ? `${formatLb(lastSet.totalLb)} lb` : null}
                {showLb && showKg ? " | " : null}
                {showKg
                  ? `${formatKg(
                      toKg(lastSet.totalLb, settings.roundingKg),
                      settings.roundingKg,
                    )} kg`
                  : null}
              </div>
            ) : (
              <div className="text-[11px] text-[color:var(--muted)]">
                Bodyweight
              </div>
            )
          ) : (
            <div className="text-[11px] text-[color:var(--muted)]">
              No history
            </div>
          )}
        </div>
      </div>

      <div className="mt-2 flex flex-wrap items-center justify-between gap-2 text-[11px] text-[color:var(--muted)]">
        <span>
          {todaySets.length} sets today{lastTime ? ` · Last ${lastTime}` : ""}
        </span>
        {targetLabel ? <span>Target {targetLabel}</span> : null}
      </div>

      <div className="mt-3 grid gap-2">
        <button
          type="button"
          onClick={lastSet ? onSame : onAddSet}
          className="min-h-[48px] w-full rounded-2xl bg-[color:var(--accent)] px-4 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
        >
          {lastSet && lastLabel ? `Log ${lastLabel}` : "Custom log"}
        </button>
        {lastSet ? (
          <div className="grid grid-cols-2 gap-2">
            <button
              type="button"
              onClick={onSameDouble}
              className="min-h-[44px] rounded-2xl border border-[var(--border)] bg-transparent px-3 text-xs uppercase tracking-[0.25em] text-[color:var(--text)]"
            >
              {lastLabel ? `Log 2x ${lastLabel}` : "Log 2x"}
            </button>
            <button
              type="button"
              onClick={onAddSet}
              className="min-h-[44px] rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] px-3 text-xs uppercase tracking-[0.3em] text-[color:var(--text)]"
            >
              Custom
            </button>
          </div>
        ) : null}
      </div>

      {todaySets.length ? (
        <div className="mt-3 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-3">
          <div className="flex items-center justify-between gap-3">
            <div className="text-[10px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
              Today
            </div>
            <button
              type="button"
              onClick={onUndoLast}
              className="min-h-[36px] rounded-full border border-[var(--border)] px-3 text-[10px] uppercase tracking-[0.3em] text-[color:var(--muted)]"
            >
              Undo last
            </button>
          </div>
          <div className="mt-2 flex flex-wrap gap-2">
            {todaySets.map((set) => {
              const isHighlighted = set.id === highlightSetId;
              return (
                <button
                  key={set.id}
                  type="button"
                  onClick={() => onEditSet(set)}
                  className={`min-h-[36px] rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-3 text-xs text-[color:var(--text)] font-mono ${
                    isHighlighted ? "ring-2 ring-[color:var(--accent-2)]" : ""
                  }`}
                >
                  {isBodyweight ? "BW" : formatLb(set.inputLb)}x{set.reps}
                </button>
              );
            })}
          </div>
        </div>
      ) : null}
    </div>
  );
};

export default ExerciseCard;

#### END components/ExerciseCard.tsx ####

#### START components/FileMirrorSync.tsx ####

"use client";

import { useEffect, useRef } from "react";
import { DB_CHANGE_EVENT } from "../lib/db";
import { writeFileMirrorNow } from "../lib/fileMirror";

const FileMirrorSync = () => {
  const debounceRef = useRef<number | null>(null);

  useEffect(() => {
    const scheduleWrite = () => {
      if (debounceRef.current) {
        window.clearTimeout(debounceRef.current);
      }
      // Debounce bursty changes (imports, multi-step edits) into one snapshot write.
      debounceRef.current = window.setTimeout(() => {
        debounceRef.current = null;
        void writeFileMirrorNow();
      }, 600);
    };

    window.addEventListener(DB_CHANGE_EVENT, scheduleWrite);
    return () => {
      window.removeEventListener(DB_CHANGE_EVENT, scheduleWrite);
      if (debounceRef.current) {
        window.clearTimeout(debounceRef.current);
      }
    };
  }, []);

  return null;
};

export default FileMirrorSync;

#### END components/FileMirrorSync.tsx ####

#### START components/Icons.tsx ####

import type { SVGProps } from "react";

const baseProps = {
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round" as const,
  strokeLinejoin: "round" as const,
};

export const IconLog = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M3 10h18" />
    <rect x="2" y="7" width="3" height="6" rx="1" />
    <rect x="19" y="7" width="3" height="6" rx="1" />
    <circle cx="12" cy="10" r="3" />
  </svg>
);

export const IconHistory = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M3 12a9 9 0 1 0 3-6.7" />
    <path d="M3 4v4h4" />
    <path d="M12 7v6l4 2" />
  </svg>
);

export const IconProgress = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M3 17l6-6 4 4 6-8" />
    <path d="M3 21h18" />
  </svg>
);

export const IconTimer = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <circle cx="12" cy="13" r="7" />
    <path d="M12 13V9" />
    <path d="M12 13l3 2" />
    <path d="M9 2h6" />
  </svg>
);

export const IconSettings = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" />
    <path d="M19.4 15a1.7 1.7 0 0 0 .3 1.9l.1.1a2 2 0 1 1-2.9 2.9l-.1-.1a1.7 1.7 0 0 0-1.9-.3 1.7 1.7 0 0 0-1 1.5V22a2 2 0 1 1-4 0v-.1a1.7 1.7 0 0 0-1-1.5 1.7 1.7 0 0 0-1.9.3l-.1.1a2 2 0 1 1-2.9-2.9l.1-.1a1.7 1.7 0 0 0 .3-1.9 1.7 1.7 0 0 0-1.5-1H2a2 2 0 1 1 0-4h.1a1.7 1.7 0 0 0 1.5-1 1.7 1.7 0 0 0-.3-1.9l-.1-.1A2 2 0 1 1 6.1 3l.1.1a1.7 1.7 0 0 0 1.9.3 1.7 1.7 0 0 0 1-1.5V2a2 2 0 1 1 4 0v.1a1.7 1.7 0 0 0 1 1.5 1.7 1.7 0 0 0 1.9-.3l.1-.1A2 2 0 1 1 20.8 6l-.1.1a1.7 1.7 0 0 0-.3 1.9 1.7 1.7 0 0 0 1.5 1H22a2 2 0 1 1 0 4h-.1a1.7 1.7 0 0 0-1.5 1Z" />
  </svg>
);

export const IconPlus = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M12 5v14" />
    <path d="M5 12h14" />
  </svg>
);

export const IconMinus = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M5 12h14" />
  </svg>
);

export const IconSwap = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M7 7h10l-3-3" />
    <path d="M17 17H7l3 3" />
  </svg>
);

export const IconChevronDown = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M6 9l6 6 6-6" />
  </svg>
);

export const IconClose = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M6 6l12 12" />
    <path d="M18 6l-12 12" />
  </svg>
);

export const IconSearch = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <circle cx="11" cy="11" r="7" />
    <path d="M20 20l-3.5-3.5" />
  </svg>
);

export const IconDownload = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M12 3v12" />
    <path d="M7 10l5 5 5-5" />
    <path d="M5 21h14" />
  </svg>
);

export const IconUpload = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M12 21V9" />
    <path d="M7 14l5-5 5 5" />
    <path d="M5 3h14" />
  </svg>
);

export const IconTrash = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <path d="M3 6h18" />
    <path d="M8 6V4h8v2" />
    <path d="M6 6l1 14h10l1-14" />
  </svg>
);

export const IconDrag = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <circle cx="8" cy="6" r="1" />
    <circle cx="16" cy="6" r="1" />
    <circle cx="8" cy="12" r="1" />
    <circle cx="16" cy="12" r="1" />
    <circle cx="8" cy="18" r="1" />
    <circle cx="16" cy="18" r="1" />
  </svg>
);

export const IconKeyboard = (props: SVGProps<SVGSVGElement>) => (
  <svg viewBox="0 0 24 24" aria-hidden="true" {...baseProps} {...props}>
    <rect x="3" y="6" width="18" height="12" rx="2" />
    <path d="M7 10h.01" />
    <path d="M10 10h.01" />
    <path d="M13 10h.01" />
    <path d="M16 10h.01" />
    <path d="M7 14h10" />
  </svg>
);

#### END components/Icons.tsx ####

#### START components/Onboarding.tsx ####

"use client";

import { useState } from "react";
import Stepper from "./Stepper";

type OnboardingProps = {
  open: boolean;
  defaultBarLb: number;
  onComplete: (barLb: number) => void;
};

const Onboarding = ({ open, defaultBarLb, onComplete }: OnboardingProps) => {
  const [barLb, setBarLb] = useState(defaultBarLb);
  const [confirmed, setConfirmed] = useState(false);
  const [step, setStep] = useState<1 | 2>(1);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-[color:var(--bg)] px-6 py-8">
      <div className="w-full max-w-md rounded-[var(--radius-lg)] border border-[var(--border)] bg-[color:var(--bg-elev)] p-6 shadow-[var(--shadow)]">
        <div className="text-[10px] uppercase tracking-[0.4em] text-[color:var(--muted)]">
          Welcome
        </div>
        <h1 className="mt-3 text-2xl font-semibold text-[color:var(--text)] font-serif">
          Set up once. Log fast forever.
        </h1>
        <p className="mt-2 text-sm text-[color:var(--muted)]">
          We log per side for barbells and calculate totals automatically.
        </p>

        {step === 1 ? (
          <>
            <div className="mt-6">
              <Stepper
                value={barLb}
                onChange={setBarLb}
                step={5}
                min={10}
                max={70}
                label="Bar weight (lb)"
              />
            </div>
            <button
              type="button"
              onClick={() => setStep(2)}
              className="mt-6 w-full rounded-2xl bg-[color:var(--accent)] px-4 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
            >
              Continue
            </button>
          </>
        ) : (
          <>
            <label className="mt-5 flex min-h-[48px] items-center gap-3 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-3 text-sm text-[color:var(--text)]">
              <input
                type="checkbox"
                checked={confirmed}
                onChange={(event) => setConfirmed(event.target.checked)}
                className="h-5 w-5 accent-[color:var(--accent)]"
              />
              I will enter plate weight for one side only.
            </label>

            <div className="mt-6 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-card)] p-4 text-sm text-[color:var(--muted)]">
              <div className="font-semibold text-[color:var(--text)]">
                Preloaded plan
              </div>
              <div className="mt-2">Workout A: Squat, Bench Press, Lat Pulldown</div>
              <div className="mt-1">Workout B: Deadlift, Overhead Press, Row</div>
            </div>

            <div className="mt-6 grid grid-cols-2 gap-3">
              <button
                type="button"
                onClick={() => setStep(1)}
                className="min-h-[44px] rounded-2xl border border-[var(--border)] px-4 text-xs uppercase tracking-[0.3em] text-[color:var(--text)]"
              >
                Back
              </button>
              <button
                type="button"
                onClick={() => onComplete(barLb)}
                disabled={!confirmed}
                className="min-h-[44px] rounded-2xl bg-[color:var(--accent)] px-4 text-xs font-semibold uppercase tracking-[0.3em] text-[color:var(--accent-ink)] disabled:opacity-40"
              >
                Start logging
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
};

export default Onboarding;

#### END components/Onboarding.tsx ####

#### START components/PwaRegister.tsx ####

"use client";

import { useEffect } from "react";

const PwaRegister = () => {
  useEffect(() => {
    if ("serviceWorker" in navigator) {
      const register = () => {
        navigator.serviceWorker.register("/sw.js").catch(() => null);
      };
      window.addEventListener("load", register, { once: true });
      return () => window.removeEventListener("load", register);
    }
    return undefined;
  }, []);

  return null;
};

export default PwaRegister;

#### END components/PwaRegister.tsx ####

#### START components/SetBuilder.tsx ####

"use client";

import { useEffect, useMemo, useState } from "react";
import BottomSheet from "./BottomSheet";
import Chip from "./Chip";
import Stepper from "./Stepper";
import { IconChevronDown, IconKeyboard } from "./Icons";
import { computeTotals, formatKg, formatLb } from "../lib/calc";
import type { Exercise, SetEntry, SettingsState } from "../lib/types";
import { DEFAULT_TAGS } from "../lib/defaults";

type SetDraft = {
  inputLb: number;
  reps: number;
  tags: string[];
  note: string;
  rpe?: number;
};

type ParsedSet = {
  inputLb: number;
  reps: number;
};

const STANDARD_PLATES = [45, 35, 25, 10, 5, 2.5];

const buildPlateBreakdown = (weight: number) => {
  let remaining = Math.max(0, weight);
  const plates: number[] = [];
  for (const plate of STANDARD_PLATES) {
    while (remaining + 0.001 >= plate) {
      plates.push(plate);
      remaining = Number((remaining - plate).toFixed(2));
    }
  }
  return { plates, remaining };
};

type SetBuilderProps = {
  open: boolean;
  mode?: "create" | "edit";
  exercise: Exercise | null;
  settings: SettingsState;
  lastSet?: SetEntry | null;
  initial?: SetEntry | null;
  onClose: () => void;
  onSave: (draft: SetDraft) => void;
  onSaveMany?: (drafts: ParsedSet[]) => void;
  onQuickSave?: (draft: SetDraft) => void;
  onDelete?: () => void;
};

const parseQuickInput = (text: string): ParsedSet[] => {
  const cleaned = text.toLowerCase().replace(/lb/g, "");
  if (!cleaned) return [];
  const results: ParsedSet[] = [];
  const pattern = /(\d+(?:\.\d+)?)[xX]([\d,]+)/g;
  for (const match of cleaned.matchAll(pattern)) {
    const weight = Number(match[1]);
    const repsList = match[2];
    if (Number.isNaN(weight)) continue;
    repsList.split(",").forEach((repText) => {
      const reps = Number(repText);
      if (!Number.isNaN(reps)) {
        results.push({ inputLb: weight, reps });
      }
    });
  }
  return results;
};

const SetBuilder = ({
  open,
  mode = "create",
  exercise,
  settings,
  lastSet,
  initial,
  onClose,
  onSave,
  onSaveMany,
  onQuickSave,
  onDelete,
}: SetBuilderProps) => {
  const [inputLb, setInputLb] = useState(0);
  const [reps, setReps] = useState(5);
  const [tags, setTags] = useState<string[]>([]);
  const [note, setNote] = useState("");
  const [rpe, setRpe] = useState<number | undefined>(undefined);
  const [showNote, setShowNote] = useState(false);
  const [showRpe, setShowRpe] = useState(false);
  const [showQuickParse, setShowQuickParse] = useState(false);
  const [quickParseText, setQuickParseText] = useState("");

  const isBodyweight = exercise?.type === "bodyweight";
  const isDumbbell = exercise?.type === "dumbbell";
  const isBarbell = exercise?.type === "barbell";
  const perSide = isBarbell || isDumbbell ? exercise?.perSide ?? true : false;
  const weightStep = isBarbell ? (perSide ? 2.5 : 5) : 5;

  // Sync draft state when opening or switching exercises.
  /* eslint-disable react-hooks/set-state-in-effect */
  useEffect(() => {
    if (!open || !exercise) return;
    const base = initial ?? lastSet;
    setInputLb(
      exercise.type === "bodyweight"
        ? 0
        : base?.inputLb ?? settings.weightPresets[2] ?? settings.barLb,
    );
    setReps(base?.reps ?? settings.repPresets[1] ?? 5);
    setTags(base?.tags ?? []);
    setNote(base?.note ?? "");
    setRpe(base?.meta?.rpe ?? undefined);
    setShowNote(Boolean(base?.note));
    setShowRpe(Boolean(base?.meta?.rpe));
    setShowQuickParse(false);
    setQuickParseText("");
  }, [open, exercise, initial, lastSet, settings]);
  /* eslint-enable react-hooks/set-state-in-effect */

  const totals = useMemo(() => {
    if (!exercise) return null;
    return computeTotals(
      inputLb,
      exercise.type,
      settings.barLb,
      settings.roundingKg,
      perSide,
    );
  }, [exercise, inputLb, perSide, settings.barLb, settings.roundingKg]);

  if (!exercise) return null;

  const unitDisplay = settings.unitDisplay;
  const showLb = unitDisplay === "both" || unitDisplay === "lb";
  const showKg = unitDisplay === "both" || unitDisplay === "kg";
  const referenceSet = initial ?? lastSet;
  const lastSummary = referenceSet
    ? exercise.type === "bodyweight"
      ? `BWx${referenceSet.reps}`
      : `${formatLb(referenceSet.inputLb)}x${referenceSet.reps}`
    : null;
  const weightDescriptor = isBarbell
    ? perSide
      ? "Per side"
      : "Total on bar"
    : isDumbbell
      ? perSide
        ? "Per dumbbell"
        : "Total load"
      : "Weight";
  const plateInput = isBarbell
    ? perSide
      ? inputLb
      : Math.max(0, (inputLb - settings.barLb) / 2)
    : inputLb;
  const plateBreakdown = isBarbell ? buildPlateBreakdown(plateInput) : null;
  const showPlates =
    isBarbell &&
    plateBreakdown &&
    plateBreakdown.plates.length > 0 &&
    plateBreakdown.remaining < 0.01;

  const handleSave = () => {
    const normalizedInput = exercise.type === "bodyweight" ? 0 : inputLb;
    onSave({ inputLb: normalizedInput, reps, tags, note, rpe });
    if (mode === "create") {
      setNote("");
      setShowNote(false);
    }
  };

  const handleQuickSave = (repValue: number) => {
    if (!onQuickSave) return;
    const normalizedInput = exercise.type === "bodyweight" ? 0 : inputLb;
    onQuickSave({ inputLb: normalizedInput, reps: repValue, tags, note, rpe });
  };

  const handleQuickParse = () => {
    if (!onSaveMany) return;
    const parsed = parseQuickInput(quickParseText);
    if (parsed.length === 0) return;
    onSaveMany(parsed);
    setQuickParseText("");
    setShowQuickParse(false);
  };

  return (
    <BottomSheet
      open={open}
      onClose={onClose}
      title={mode === "edit" ? "Edit set" : "Log set"}
      footer={
        <div className="flex items-center gap-3">
          {mode === "edit" && onDelete ? (
            <button
              type="button"
              onClick={onDelete}
              className="flex-1 rounded-2xl border border-[var(--border)] bg-transparent px-4 py-3 text-sm uppercase tracking-[0.2em] text-[color:var(--danger)]"
            >
              Delete
            </button>
          ) : null}
          <button
            type="button"
            onClick={handleSave}
            className="flex-1 rounded-2xl bg-[color:var(--accent)] px-4 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
          >
            {mode === "edit" ? "Save changes" : "Log set"}
          </button>
        </div>
      }
    >
      <section className="flex flex-col gap-4">
        {lastSummary ? (
          <div className="rounded-2xl border border-dashed border-[var(--border)] bg-[color:var(--bg-elev)] p-3 text-sm text-[color:var(--muted)]">
            <div className="text-[10px] uppercase tracking-[0.3em]">Last logged</div>
            <div className="mt-1 text-base font-semibold text-[color:var(--text)] font-mono">
              {lastSummary}
            </div>
          </div>
        ) : null}
        {!isBodyweight ? (
          <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
            <div className="flex items-start justify-between gap-3">
              <div>
                <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                  Weight
                </div>
                <div className="mt-1 text-xs text-[color:var(--muted)]">
                  {weightDescriptor} (lb)
                </div>
              </div>
              {totals ? (
                <div className="text-right text-[11px] text-[color:var(--muted)]">
                  <div className="uppercase tracking-[0.3em]">Total</div>
                  <div className="mt-1 font-mono text-sm text-[color:var(--text)]">
                    {showLb ? `${formatLb(totals.totalLb)} lb` : null}
                    {showLb && showKg ? " | " : null}
                    {showKg
                      ? `${formatKg(totals.totalKg, settings.roundingKg)} kg`
                      : null}
                  </div>
                </div>
              ) : null}
            </div>
            <div className="mt-2 text-3xl font-semibold text-[color:var(--text)] font-mono">
              {formatLb(inputLb)}
            </div>
            {isBarbell ? (
              <div className="mt-1 text-[11px] text-[color:var(--muted)]">
                Bar {settings.barLb} lb {perSide ? "included" : "inside total"}
              </div>
            ) : null}
            <div className="mt-3 grid grid-cols-4 gap-2">
              {settings.weightPresets.map((preset) => (
                <Chip
                  key={preset}
                  size="sm"
                  selected={Math.abs(inputLb - preset) < 0.01}
                  onClick={() => setInputLb(preset)}
                >
                  {preset}
                </Chip>
              ))}
            </div>
            <div className="mt-2 flex flex-wrap gap-2">
              {[5, 2.5, 1].map((delta) => (
                <Chip
                  key={delta}
                  size="sm"
                  onClick={() => setInputLb((prev) => Math.max(0, prev + delta))}
                >
                  +{delta}
                </Chip>
              ))}
            </div>
            <div className="mt-3">
              <Stepper
                value={inputLb}
                onChange={setInputLb}
                step={weightStep}
                min={0}
                label={weightDescriptor}
                format={formatLb}
              />
            </div>
            {showPlates ? (
              <div className="mt-2 text-[11px] text-[color:var(--muted)]">
                Plates (std):{" "}
                {plateBreakdown?.plates.map((plate) => formatLb(plate)).join(" + ")}
              </div>
            ) : null}
          </div>
        ) : null}

        <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Reps
          </div>
          <div className="mt-2 flex flex-wrap gap-2">
            {settings.repPresets.map((rep) => (
              <Chip
                key={rep}
                selected={reps === rep}
                onClick={() => setReps(rep)}
              >
                {rep}
              </Chip>
            ))}
          </div>
          <div className="mt-3">
            <Stepper value={reps} onChange={setReps} step={1} min={1} />
          </div>
        </div>

        {mode === "create" && onQuickSave ? (
          <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
            <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
              Rapid log
            </div>
            <div className="mt-1 text-sm text-[color:var(--muted)]">
              Tap reps to log immediately
            </div>
            <div className="mt-3 flex gap-2 overflow-x-auto pb-1">
              {settings.repPresets.map((rep) => (
                <Chip key={rep} onClick={() => handleQuickSave(rep)}>
                  {rep}
                </Chip>
              ))}
            </div>
          </div>
        ) : null}

        <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Tags + notes
          </div>
          <div className="mt-1 text-sm text-[color:var(--muted)]">
            Tap to toggle
          </div>
          <div className="mt-3 flex flex-wrap gap-2">
            {DEFAULT_TAGS.map((tag) => {
              const selected = tags.includes(tag);
              return (
                <Chip
                  key={tag}
                  selected={selected}
                  onClick={() =>
                    setTags((prev) =>
                      prev.includes(tag)
                        ? prev.filter((item) => item !== tag)
                        : [...prev, tag],
                    )
                  }
                >
                  {tag}
                </Chip>
              );
            })}
          </div>
          <div className="mt-4">
            <button
              type="button"
              onClick={() => setShowNote((prev) => !prev)}
              className="flex min-h-[44px] w-full items-center justify-between rounded-xl border border-[var(--border)] bg-transparent px-3 py-2 text-sm text-[color:var(--muted)]"
            >
              Add note
              <IconChevronDown className={`h-4 w-4 ${showNote ? "rotate-180" : ""}`} />
            </button>
            {showNote ? (
              <textarea
                value={note}
                onChange={(event) => setNote(event.target.value)}
                placeholder="Optional note"
                className="mt-2 w-full rounded-xl border border-[var(--border)] bg-[color:var(--bg-card)] px-3 py-2 text-sm text-[color:var(--text)]"
                rows={2}
              />
            ) : null}
          </div>
          <div className="mt-4">
            <button
              type="button"
              onClick={() => setShowRpe((prev) => !prev)}
              className="flex min-h-[44px] w-full items-center justify-between rounded-xl border border-[var(--border)] bg-transparent px-3 py-2 text-sm text-[color:var(--muted)]"
            >
              RPE
              <IconChevronDown className={`h-4 w-4 ${showRpe ? "rotate-180" : ""}`} />
            </button>
            {showRpe ? (
              <div className="mt-2">
                <Stepper
                  value={rpe ?? 8}
                  onChange={(next) => setRpe(next)}
                  step={0.5}
                  min={6}
                  max={10}
                />
              </div>
            ) : null}
          </div>
        </div>

        {mode === "create" && !isBodyweight ? (
          <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
            <button
              type="button"
              onClick={() => setShowQuickParse((prev) => !prev)}
              className="flex min-h-[44px] w-full items-center justify-between text-sm text-[color:var(--muted)]"
            >
              <span className="flex items-center gap-2">
                <IconKeyboard className="h-4 w-4" />
                Quick entry
              </span>
              <IconChevronDown
                className={`h-4 w-4 ${showQuickParse ? "rotate-180" : ""}`}
              />
            </button>
            {showQuickParse ? (
              <div className="mt-3 space-y-2">
                <input
                  value={quickParseText}
                  onChange={(event) => setQuickParseText(event.target.value)}
                  placeholder="45x12,10,8"
                  className="min-h-[44px] w-full rounded-xl border border-[var(--border)] bg-[color:var(--bg-card)] px-3 py-2 text-sm text-[color:var(--text)]"
                />
                <button
                  type="button"
                  onClick={handleQuickParse}
                  className="min-h-[44px] w-full rounded-xl bg-[color:var(--accent-2)] px-3 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-[color:var(--accent-ink)]"
                >
                  Log parsed sets
                </button>
              </div>
            ) : null}
          </div>
        ) : null}
      </section>
    </BottomSheet>
  );
};

export default SetBuilder;

#### END components/SetBuilder.tsx ####

#### START components/SetComposer.tsx ####

"use client";

import { useEffect, useMemo, useState } from "react";
import BottomSheet from "./BottomSheet";
import Chip from "./Chip";
import Stepper from "./Stepper";
import { computeTotals, formatKg, formatLb } from "../lib/calc";
import type { Exercise, SetEntry, SettingsState } from "../lib/types";

export type SetDraft = {
  inputLb: number;
  reps: number;
  tags: string[];
  note: string;
  rpe?: number;
};

type SetSeed = {
  inputLb: number;
  reps: number;
  tags?: string[];
  note?: string;
  rpe?: number;
};

type SetComposerProps = {
  open: boolean;
  mode?: "create" | "edit";
  exercise: Exercise | null;
  settings: SettingsState;
  seed?: SetSeed | null;
  initial?: SetEntry | null;
  onClose: () => void;
  onSave: (draft: SetDraft) => void;
  onDelete?: () => void;
};

const SetComposer = ({
  open,
  mode = "create",
  exercise,
  settings,
  seed,
  initial,
  onClose,
  onSave,
  onDelete,
}: SetComposerProps) => {
  const [inputLb, setInputLb] = useState(0);
  const [reps, setReps] = useState(5);
  const [tags, setTags] = useState<string[]>([]);
  const [note, setNote] = useState("");
  const [rpe, setRpe] = useState<number | undefined>(undefined);

  const isBodyweight = exercise?.type === "bodyweight";
  const isDumbbell = exercise?.type === "dumbbell";
  const isBarbell = exercise?.type === "barbell";
  const perSide = isBarbell || isDumbbell ? exercise?.perSide ?? true : false;

  // Sync draft state when opening or switching exercises.
  /* eslint-disable react-hooks/set-state-in-effect */
  useEffect(() => {
    if (!open || !exercise) return;
    const base = mode === "edit" ? initial : seed;
    const baseInput = base?.inputLb ?? settings.weightPresets[2] ?? settings.barLb;
    const baseReps = base?.reps ?? settings.repPresets[1] ?? 8;
    const baseTags = mode === "edit" ? initial?.tags ?? [] : seed?.tags ?? [];
    const baseNote = mode === "edit" ? initial?.note ?? "" : seed?.note ?? "";
    const baseRpe = mode === "edit" ? initial?.meta?.rpe : seed?.rpe;
    setInputLb(isBodyweight ? 0 : baseInput);
    setReps(baseReps);
    setTags(baseTags);
    setNote(baseNote);
    setRpe(baseRpe);
  }, [exercise, initial, mode, open, seed, settings, isBodyweight]);
  /* eslint-enable react-hooks/set-state-in-effect */

  const totals = useMemo(() => {
    if (!exercise || isBodyweight) return null;
    return computeTotals(
      inputLb,
      exercise.type,
      settings.barLb,
      settings.roundingKg,
      perSide,
    );
  }, [exercise, inputLb, isBodyweight, perSide, settings.barLb, settings.roundingKg]);

  if (!exercise) return null;

  const unitDisplay = settings.unitDisplay;
  const showLb = unitDisplay === "both" || unitDisplay === "lb";
  const showKg = unitDisplay === "both" || unitDisplay === "kg";
  const weightDescriptor = isBarbell
    ? perSide
      ? "Per side"
      : "Total on bar"
    : isDumbbell
      ? perSide
        ? "Per dumbbell"
        : "Total load"
      : "Weight";
  const weightStep = isBarbell ? (perSide ? 2.5 : 5) : 5;
  const minWeight = isBarbell && !perSide ? settings.barLb : 0;
  const plateSide = isBarbell
    ? perSide
      ? inputLb
      : Math.max(0, (inputLb - settings.barLb) / 2)
    : null;
  const weightJumps = isBarbell
    ? perSide
      ? [2.5, 5, 10]
      : [5, 10, 20]
    : [5, 10, 20];
  const repPresets = settings.repPresets.length
    ? settings.repPresets
    : [5, 8, 10, 12];
  const warmupActive = tags.includes("warmup");

  const toggleWarmup = () => {
    setTags((prev) => {
      if (prev.includes("warmup")) {
        return prev.filter((tag) => tag !== "warmup");
      }
      return [...prev, "warmup"];
    });
  };

  const handleSave = () => {
    const normalizedInput = isBodyweight ? 0 : inputLb;
    onSave({
      inputLb: normalizedInput,
      reps,
      tags,
      note,
      rpe,
    });
  };

  return (
    <BottomSheet
      open={open}
      onClose={onClose}
      title={mode === "edit" ? "Edit set" : "Log set"}
      footer={
        <div className="flex items-center gap-3">
          {mode === "edit" && onDelete ? (
            <button
              type="button"
              onClick={onDelete}
              className="flex-1 rounded-2xl border border-[var(--border)] bg-transparent px-4 py-3 text-sm uppercase tracking-[0.2em] text-[color:var(--danger)]"
            >
              Delete
            </button>
          ) : null}
          <button
            type="button"
            onClick={handleSave}
            className="flex-1 rounded-2xl bg-[color:var(--accent)] px-4 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
          >
            {mode === "edit" ? "Save changes" : "Log set"}
          </button>
        </div>
      }
    >
      <section className="flex flex-col gap-4">
        {!isBodyweight ? (
          <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
            <div className="flex items-start justify-between gap-3">
              <div>
                <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                  Weight
                </div>
                <div className="mt-1 text-xs text-[color:var(--muted)]">
                  {weightDescriptor} (lb)
                </div>
              </div>
              {totals ? (
                <div className="text-right text-[11px] text-[color:var(--muted)]">
                  <div className="uppercase tracking-[0.3em]">Total</div>
                  <div className="mt-1 font-mono text-sm text-[color:var(--text)]">
                    {showLb ? `${formatLb(totals.totalLb)} lb` : null}
                    {showLb && showKg ? " | " : null}
                    {showKg
                      ? `${formatKg(totals.totalKg, settings.roundingKg)} kg`
                      : null}
                  </div>
                </div>
              ) : null}
            </div>
            <div className="mt-3 text-3xl font-semibold text-[color:var(--text)] font-mono">
              {formatLb(inputLb)} lb
            </div>
            {isBarbell ? (
              <div className="mt-1 text-[11px] text-[color:var(--muted)]">
                Per side {formatLb(plateSide ?? 0)} lb · Bar {settings.barLb} lb
              </div>
            ) : null}
            <div className="mt-3 flex flex-wrap gap-2">
              {weightJumps.map((delta) => (
                <Chip
                  key={delta}
                  size="sm"
                  onClick={() =>
                    setInputLb((prev) => Math.max(minWeight, prev + delta))
                  }
                >
                  +{delta}
                </Chip>
              ))}
            </div>
            <div className="mt-3">
              <Stepper
                value={inputLb}
                onChange={setInputLb}
                step={weightStep}
                min={minWeight}
                label={weightDescriptor}
                format={formatLb}
              />
            </div>
          </div>
        ) : (
          <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4 text-sm text-[color:var(--muted)]">
            Logging bodyweight reps only.
          </div>
        )}

        <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
          <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
            Reps
          </div>
          <div className="mt-2 flex flex-wrap gap-2">
            {repPresets.map((rep) => (
              <Chip
                key={rep}
                selected={reps === rep}
                onClick={() => setReps(rep)}
              >
                {rep}
              </Chip>
            ))}
          </div>
          <div className="mt-3">
            <Stepper value={reps} onChange={setReps} step={1} min={1} />
          </div>
        </div>

        <div className="rounded-2xl border border-[var(--border)] bg-[color:var(--bg-elev)] p-4">
          <div className="flex flex-wrap items-center justify-between gap-3">
            <div>
              <div className="text-[11px] uppercase tracking-[0.35em] text-[color:var(--muted)]">
                Tags
              </div>
              <div className="mt-1 text-xs text-[color:var(--muted)]">
                Tap to mark warmup
              </div>
            </div>
            <button
              type="button"
              onClick={toggleWarmup}
              className={`min-h-[44px] rounded-full border px-4 text-xs uppercase tracking-[0.3em] transition ${
                warmupActive
                  ? "border-[var(--accent)] bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
                  : "border-[var(--border)] bg-transparent text-[color:var(--muted)]"
              }`}
            >
              Warmup
            </button>
          </div>
        </div>
      </section>
    </BottomSheet>
  );
};

export default SetComposer;

#### END components/SetComposer.tsx ####

#### START components/Stepper.tsx ####

"use client";

import { useEffect, useRef } from "react";
import { IconMinus, IconPlus } from "./Icons";

type StepperProps = {
  value: number;
  onChange: (next: number) => void;
  step?: number;
  min?: number;
  max?: number;
  label?: string;
  format?: (value: number) => string;
};

const Stepper = ({
  value,
  onChange,
  step = 1,
  min = -Infinity,
  max = Infinity,
  label,
  format,
}: StepperProps) => {
  const holdRef = useRef<number | null>(null);
  const valueRef = useRef(value);

  useEffect(() => {
    valueRef.current = value;
  }, [value]);

  const applyDelta = (delta: number) => {
    const next = Math.min(max, Math.max(min, valueRef.current + delta));
    onChange(Number.isFinite(next) ? next : value);
  };

  const startHold = (direction: 1 | -1) => {
    let ticks = 0;
    applyDelta(step * direction);
    holdRef.current = window.setInterval(() => {
      ticks += 1;
      const multiplier = ticks > 14 ? 5 : ticks > 6 ? 2 : 1;
      applyDelta(step * direction * multiplier);
    }, 120);
  };

  const stopHold = () => {
    if (holdRef.current) {
      window.clearInterval(holdRef.current);
      holdRef.current = null;
    }
  };

  return (
    <div className="flex items-center justify-between gap-4 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-3 shadow-[var(--shadow)]">
      <div>
        {label ? (
          <div className="text-[11px] uppercase tracking-[0.3em] text-[color:var(--muted)]">
            {label}
          </div>
        ) : null}
        <div className="text-xl font-semibold text-[color:var(--text)] font-mono">
          {format ? format(value) : value}
        </div>
      </div>
      <div className="flex items-center gap-2">
        <button
          type="button"
          className="grid h-12 w-12 place-items-center rounded-full border border-[var(--border)] bg-[color:var(--chip)] text-[color:var(--text)]"
          onPointerDown={() => startHold(-1)}
          onPointerUp={stopHold}
          onPointerLeave={stopHold}
          onPointerCancel={stopHold}
          aria-label="Decrease"
        >
          <IconMinus className="h-4 w-4" />
        </button>
        <button
          type="button"
          className="grid h-12 w-12 place-items-center rounded-full bg-[color:var(--accent)] text-[color:var(--accent-ink)]"
          onPointerDown={() => startHold(1)}
          onPointerUp={stopHold}
          onPointerLeave={stopHold}
          onPointerCancel={stopHold}
          aria-label="Increase"
        >
          <IconPlus className="h-4 w-4" />
        </button>
      </div>
    </div>
  );
};

export default Stepper;

#### END components/Stepper.tsx ####

#### START components/SwipeRow.tsx ####

"use client";

import type { ReactNode } from "react";
import { useRef, useState } from "react";
import { IconTrash } from "./Icons";

type SwipeRowProps = {
  children: ReactNode;
  onDelete: () => void;
};

const SwipeRow = ({ children, onDelete }: SwipeRowProps) => {
  const startX = useRef(0);
  const [offset, setOffset] = useState(0);
  const [open, setOpen] = useState(false);

  const handlePointerDown = (event: React.PointerEvent<HTMLDivElement>) => {
    startX.current = event.clientX;
  };

  const handlePointerMove = (event: React.PointerEvent<HTMLDivElement>) => {
    const delta = event.clientX - startX.current;
    if (delta >= 0) return;
    setOffset(Math.max(delta, -90));
  };

  const handlePointerUp = () => {
    if (offset < -50) {
      setOpen(true);
      setOffset(-90);
    } else {
      setOpen(false);
      setOffset(0);
    }
  };

  const handleReset = () => {
    setOpen(false);
    setOffset(0);
  };

  return (
    <div className="relative overflow-hidden">
      <div className="absolute inset-y-0 right-0 flex w-24 items-center justify-center bg-[color:var(--danger)]">
        <button
          type="button"
          onClick={() => {
            onDelete();
            handleReset();
          }}
          className="flex flex-col items-center gap-1 text-xs uppercase tracking-[0.2em] text-white"
        >
          <IconTrash className="h-4 w-4" />
          Delete
        </button>
      </div>
      <div
        className="relative touch-pan-y"
        style={{ transform: `translateX(${offset}px)` }}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerUp}
      >
        <div onClick={open ? handleReset : undefined}>{children}</div>
      </div>
    </div>
  );
};

export default SwipeRow;

#### END components/SwipeRow.tsx ####

#### START components/TabBar.tsx ####

"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { IconHistory, IconLog, IconProgress, IconSettings } from "./Icons";

const tabs = [
  { href: "/", label: "Log", Icon: IconLog },
  { href: "/history", label: "History", Icon: IconHistory },
  { href: "/progress", label: "Progress", Icon: IconProgress },
  { href: "/settings", label: "Settings", Icon: IconSettings },
];

const TabBar = () => {
  const pathname = usePathname();

  return (
    <nav className="fixed bottom-0 left-0 right-0 z-40 pb-[env(safe-area-inset-bottom)]">
      <div className="mx-auto w-full max-w-3xl px-4 pb-4">
        <div className="flex items-center justify-between rounded-full border border-[var(--border)] bg-[color:var(--bg-card)] px-3 py-2 shadow-[var(--shadow)]">
          {tabs.map(({ href, label, Icon }) => {
            const active = pathname === href;
            return (
              <Link
                key={href}
                href={href}
                aria-current={active ? "page" : undefined}
                className={`flex min-h-[44px] min-w-[64px] flex-col items-center justify-center gap-1 rounded-full px-3 text-[10px] uppercase tracking-[0.28em] transition ${
                  active
                    ? "bg-[color:var(--accent)] text-[color:var(--accent-ink)] shadow-[var(--shadow)]"
                    : "text-[color:var(--muted)] hover:text-[color:var(--text)]"
                }`}
              >
                <Icon className="h-4 w-4" />
                <span>{label}</span>
              </Link>
            );
          })}
        </div>
      </div>
    </nav>
  );
};

export default TabBar;

#### END components/TabBar.tsx ####

#### START components/Toast.tsx ####

import type { ReactNode } from "react";

type ToastProps = {
  message: ReactNode;
  actionLabel?: string;
  onAction?: () => void;
  onClose?: () => void;
};

const Toast = ({ message, actionLabel, onAction, onClose }: ToastProps) => (
  <div className="fixed bottom-24 left-0 right-0 z-50 mx-auto flex w-[calc(100%-2.5rem)] max-w-md items-center justify-between gap-4 rounded-2xl border border-[var(--border)] bg-[color:var(--bg-card)] px-4 py-3 text-sm text-[color:var(--text)] shadow-[var(--shadow)]">
    <div className="flex-1 text-sm text-[color:var(--text)]">{message}</div>
    {actionLabel ? (
      <button
        type="button"
        onClick={onAction}
        className="min-h-[44px] rounded-full bg-[color:var(--accent)] px-4 py-1 text-xs font-semibold uppercase tracking-[0.2em] text-[color:var(--accent-ink)]"
      >
        {actionLabel}
      </button>
    ) : null}
    {onClose ? (
      <button
        type="button"
        onClick={onClose}
        className="min-h-[44px] px-2 text-xs uppercase tracking-[0.2em] text-[color:var(--muted)]"
      >
        Close
      </button>
    ) : null}
  </div>
);

export default Toast;

#### END components/Toast.tsx ####

#### START eslint.config.mjs ####

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;

#### END eslint.config.mjs ####

#### START lib/backup.ts ####

import type {
  BackupPayload,
  Exercise,
  SessionEntry,
  SetEntry,
  SettingsState,
} from "./types";

type SerializeBackupOptions = {
  pretty?: boolean;
};

export const serializeBackup = (
  exercises: Exercise[],
  sets: SetEntry[],
  settings: SettingsState,
  sessions: SessionEntry[] = [],
  options: SerializeBackupOptions = {},
): string => {
  const payload: BackupPayload = {
    version: 2,
    exportedAt: Date.now(),
    exercises,
    sets,
    sessions: sessions.length ? sessions : undefined,
    settings,
  };
  const pretty = options.pretty !== false;
  return JSON.stringify(payload, null, pretty ? 2 : 0);
};

export const parseBackup = (text: string): BackupPayload => {
  const data = JSON.parse(text) as BackupPayload;
  if (!data || !Array.isArray(data.exercises) || !Array.isArray(data.sets)) {
    throw new Error("Invalid backup format");
  }
  return data;
};

const csvEscape = (value: string | number | null | undefined) => {
  const text = value == null ? "" : String(value);
  if (/[,\n"]/.test(text)) {
    return `"${text.replace(/"/g, '""')}"`;
  }
  return text;
};

export const serializeSetsCsv = (
  sets: SetEntry[],
  exercises: Exercise[],
): string => {
  const nameById = new Map(exercises.map((exercise) => [exercise.id, exercise]));
  const header = [
    "date",
    "exercise",
    "type",
    "reps",
    "inputLb",
    "barLbSnapshot",
    "totalLb",
    "totalKg",
    "note",
    "tags",
    "rpe",
    "ts",
  ];
  const rows = sets.map((set) => {
    const exercise = nameById.get(set.exerciseId);
    return [
      set.date,
      exercise?.name ?? "",
      exercise?.type ?? "",
      set.reps,
      set.inputLb,
      set.barLbSnapshot,
      set.totalLb,
      set.totalKg,
      set.note ?? "",
      set.tags?.join("|") ?? "",
      set.meta?.rpe ?? "",
      set.ts,
    ].map(csvEscape);
  });
  return [header.join(","), ...rows.map((row) => row.join(","))].join("\n");
};

const parseCsvLine = (line: string) => {
  const result: string[] = [];
  let current = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if (char === "," && !inQuotes) {
      result.push(current);
      current = "";
      continue;
    }
    current += char;
  }
  result.push(current);
  return result;
};

export type CsvSetRow = {
  date: string;
  exercise: string;
  type?: string;
  reps: number;
  inputLb: number;
  barLbSnapshot: number;
  totalLb: number;
  totalKg: number;
  note?: string;
  tags?: string[];
  rpe?: number;
  ts?: number;
};

export const parseSetsCsv = (text: string): CsvSetRow[] => {
  const lines = text
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter(Boolean);
  if (lines.length <= 1) return [];
  const header = parseCsvLine(lines[0]).map((value) => value.toLowerCase());
  return lines.slice(1).map((line) => {
    const values = parseCsvLine(line);
    const record: Record<string, string> = {};
    header.forEach((key, index) => {
      record[key] = values[index] ?? "";
    });
    return {
      date: record.date,
      exercise: record.exercise,
      type: record.type || undefined,
      reps: Number(record.reps || 0),
      inputLb: Number(record.inputlb || record.inputLb || 0),
      barLbSnapshot: Number(record.barlbsnapshot || record.barLbSnapshot || 0),
      totalLb: Number(record.totallb || record.totalLb || 0),
      totalKg: Number(record.totalkg || record.totalKg || 0),
      note: record.note || undefined,
      tags: record.tags ? record.tags.split("|") : undefined,
      rpe: record.rpe ? Number(record.rpe) : undefined,
      ts: record.ts ? Number(record.ts) : undefined,
    };
  });
};

#### END lib/backup.ts ####

#### START lib/calc.ts ####

import type { E1RMFormula, ExerciseType } from "./types";

export const LB_TO_KG = 0.45359237;

const getDecimals = (value: number) => {
  const text = value.toString();
  if (!text.includes(".")) return 0;
  return text.split(".")[1]?.length ?? 0;
};

export const toKg = (lb: number, rounding = 0.1): number => {
  const value = lb * LB_TO_KG;
  if (rounding <= 0) return value;
  return Math.round(value / rounding) * rounding;
};

export const computeTotals = (
  inputLb: number,
  type: ExerciseType,
  barLb: number,
  rounding = 0.1,
  perSide = true,
) => {
  let totalLb = inputLb;
  switch (type) {
    case "barbell":
      totalLb = perSide ? inputLb * 2 + barLb : inputLb;
      break;
    case "dumbbell":
      totalLb = perSide ? inputLb * 2 : inputLb;
      break;
    case "bodyweight":
      totalLb = 0;
      break;
    default:
      totalLb = inputLb;
  }
  const totalKg = toKg(totalLb, rounding);
  return { totalLb, totalKg };
};

export const formatLb = (lb: number) => {
  if (Number.isInteger(lb)) return lb.toString();
  return lb.toFixed(1);
};

export const formatKg = (kg: number, rounding = 0.1) => {
  if (rounding <= 0) return kg.toFixed(2);
  return kg.toFixed(getDecimals(rounding));
};

export const estimateE1RM = (
  weightLb: number,
  reps: number,
  formula: E1RMFormula,
) => {
  if (reps <= 1) return weightLb;
  if (formula === "brzycki") {
    if (reps >= 37) return weightLb;
    return weightLb * (36 / (37 - reps));
  }
  return weightLb * (1 + reps / 30);
};

#### END lib/calc.ts ####

#### START lib/date.ts ####

export const getLocalDateKey = (ts: number = Date.now()) => {
  const date = new Date(ts);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const parseDateKey = (dateKey: string) => {
  const [year, month, day] = dateKey.split("-").map(Number);
  return new Date(year, month - 1, day);
};

export const getDateKeyOffset = (offsetDays: number, baseKey?: string) => {
  const date = baseKey ? parseDateKey(baseKey) : new Date();
  date.setDate(date.getDate() + offsetDays);
  return getLocalDateKey(date.getTime());
};

export const formatDateHeading = (dateKey: string) => {
  const date = parseDateKey(dateKey);
  return date.toLocaleDateString(undefined, {
    weekday: "short",
    month: "short",
    day: "numeric",
  });
};

export const formatDateLong = (dateKey: string) => {
  const date = parseDateKey(dateKey);
  return date.toLocaleDateString(undefined, {
    weekday: "long",
    month: "short",
    day: "numeric",
  });
};

export const formatSessionDateLabel = (dateKey: string, todayKey?: string) => {
  const today = todayKey ?? getLocalDateKey();
  if (dateKey === today) return "Today";
  const yesterday = getDateKeyOffset(-1, today);
  if (dateKey === yesterday) return "Yesterday";
  return formatDateHeading(dateKey);
};

export const formatShortTime = (ts: number) => {
  const date = new Date(ts);
  return date.toLocaleTimeString(undefined, {
    hour: "numeric",
    minute: "2-digit",
  });
};

#### END lib/date.ts ####

#### START lib/db/index.ts ####

import type {
  Exercise,
  SessionEntry,
  SetEntry,
  SettingsState,
  WorkoutId,
} from "../types";

const DB_NAME = "gymlog";
const DB_VERSION = 3;

let dbPromise: Promise<IDBDatabase> | null = null;

const openDbRequest = (version?: number) =>
  new Promise<IDBDatabase>((resolve, reject) => {
    const request =
      typeof version === "number"
        ? indexedDB.open(DB_NAME, version)
        : indexedDB.open(DB_NAME);
    request.onupgradeneeded = () => {
      const db = request.result;
      const tx = request.transaction ?? null;
      if (!db.objectStoreNames.contains("exercises")) {
        db.createObjectStore("exercises", { keyPath: "id" });
      }

      let setStore: IDBObjectStore | null = null;
      if (!db.objectStoreNames.contains("sets")) {
        setStore = db.createObjectStore("sets", { keyPath: "id" });
      } else if (tx) {
        setStore = tx.objectStore("sets");
      }
      if (setStore) {
        if (!setStore.indexNames.contains("date")) {
          setStore.createIndex("date", "date", { unique: false });
        }
        if (!setStore.indexNames.contains("exerciseId")) {
          setStore.createIndex("exerciseId", "exerciseId", { unique: false });
        }
        if (!setStore.indexNames.contains("ts")) {
          setStore.createIndex("ts", "ts", { unique: false });
        }
        if (!setStore.indexNames.contains("date_ts")) {
          setStore.createIndex("date_ts", ["date", "ts"], { unique: false });
        }
        if (!setStore.indexNames.contains("exerciseId_date")) {
          setStore.createIndex("exerciseId_date", ["exerciseId", "date"], {
            unique: false,
          });
        }
      }

      const hadSessions = db.objectStoreNames.contains("sessions");
      if (!hadSessions) {
        db.createObjectStore("sessions", { keyPath: "date" });
      }
      if (!db.objectStoreNames.contains("settings")) {
        db.createObjectStore("settings", { keyPath: "key" });
      }
      if (!db.objectStoreNames.contains("mirror")) {
        db.createObjectStore("mirror", { keyPath: "key" });
      }

      if (!hadSessions && tx && setStore && db.objectStoreNames.contains("exercises")) {
        const exercisesStore = tx.objectStore("exercises");
        const sessionsStore = tx.objectStore("sessions");
        const exercisesRequest = exercisesStore.getAll();
        exercisesRequest.onsuccess = () => {
          const exercises = exercisesRequest.result as Exercise[];
          const workoutByExercise = new Map(
            exercises.map((exercise) => [exercise.id, exercise.workout]),
          );
          const setsRequest = setStore.getAll();
          setsRequest.onsuccess = () => {
            const sets = (setsRequest.result as SetEntry[]).sort(
              (a, b) => a.ts - b.ts,
            );
            const byDate = new Map<string, SessionEntry>();
            sets.forEach((setEntry) => {
              const workoutId = workoutByExercise.get(setEntry.exerciseId);
              const existing = byDate.get(setEntry.date);
              if (!existing) {
                byDate.set(setEntry.date, {
                  date: setEntry.date,
                  workoutId,
                  createdAtTs: setEntry.ts,
                  updatedAtTs: setEntry.ts,
                  exercisesSnapshot: [setEntry.exerciseId],
                });
                return;
              }
              const nextWorkout =
                existing.workoutId &&
                workoutId &&
                existing.workoutId !== workoutId
                  ? "Custom"
                  : existing.workoutId ?? workoutId;
              const snapshot = existing.exercisesSnapshot ?? [];
              if (!snapshot.includes(setEntry.exerciseId)) {
                snapshot.push(setEntry.exerciseId);
              }
              byDate.set(setEntry.date, {
                ...existing,
                workoutId: nextWorkout,
                updatedAtTs: Math.max(existing.updatedAtTs, setEntry.ts),
                createdAtTs: Math.min(existing.createdAtTs, setEntry.ts),
                exercisesSnapshot: snapshot,
              });
            });
            byDate.forEach((session) => {
              sessionsStore.put(session);
            });
          };
        };
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

const openDb = () => {
  if (typeof window === "undefined") {
    return Promise.reject(new Error("IndexedDB unavailable on server"));
  }
  if (dbPromise) return dbPromise;
  dbPromise = openDbRequest(DB_VERSION).catch((error) => {
    if (error instanceof DOMException && error.name === "VersionError") {
      return openDbRequest();
    }
    throw error;
  });
  dbPromise.catch(() => {
    dbPromise = null;
  });
  return dbPromise;
};

const requestToPromise = <T>(request: IDBRequest<T>) =>
  new Promise<T>((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

const transactionDone = (tx: IDBTransaction) =>
  new Promise<void>((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });

export const DB_CHANGE_EVENT = "gymlog:db-change";

const notifyDbChange = (source: string) => {
  if (typeof window === "undefined") return;
  window.dispatchEvent(
    new CustomEvent(DB_CHANGE_EVENT, {
      detail: { source, ts: Date.now() },
    }),
  );
};

export const getAllExercises = async () => {
  const db = await openDb();
  const tx = db.transaction("exercises", "readonly");
  const store = tx.objectStore("exercises");
  const items = await requestToPromise<Exercise[]>(store.getAll());
  await transactionDone(tx);
  return items.sort((a, b) => a.order - b.order);
};

export const saveExercise = async (exercise: Exercise) => {
  const db = await openDb();
  const tx = db.transaction("exercises", "readwrite");
  tx.objectStore("exercises").put(exercise);
  await transactionDone(tx);
  notifyDbChange("saveExercise");
};

export const saveExercises = async (exercises: Exercise[]) => {
  const db = await openDb();
  const tx = db.transaction("exercises", "readwrite");
  const store = tx.objectStore("exercises");
  exercises.forEach((exercise) => store.put(exercise));
  await transactionDone(tx);
  notifyDbChange("saveExercises");
};

export const deleteExercise = async (id: string) => {
  const db = await openDb();
  const tx = db.transaction("exercises", "readwrite");
  tx.objectStore("exercises").delete(id);
  await transactionDone(tx);
  notifyDbChange("deleteExercise");
};

export const reorderExercises = async (
  workout: WorkoutId,
  orderedIds: string[],
) => {
  const exercises = await getAllExercises();
  const updated = exercises.map((exercise) => {
    if (exercise.workout !== workout) return exercise;
    const index = orderedIds.indexOf(exercise.id);
    return {
      ...exercise,
      order: index === -1 ? exercise.order : index,
    };
  });
  await saveExercises(updated);
};

export const addSet = async (entry: SetEntry) => {
  const db = await openDb();
  const storeNames: Array<"sets" | "sessions" | "exercises"> = ["sets"];
  const hasSessions = db.objectStoreNames.contains("sessions");
  const hasExercises = db.objectStoreNames.contains("exercises");
  if (hasSessions) storeNames.push("sessions");
  if (hasExercises) storeNames.push("exercises");
  const tx = db.transaction(storeNames, "readwrite");
  const setStore = tx.objectStore("sets");
  setStore.put(entry);

  if (hasSessions && hasExercises) {
    const exercisesStore = tx.objectStore("exercises");
    const sessionsStore = tx.objectStore("sessions");
    const exercise = await requestToPromise<Exercise | undefined>(
      exercisesStore.get(entry.exerciseId),
    );
    const existing = await requestToPromise<SessionEntry | undefined>(
      sessionsStore.get(entry.date),
    );
    const workoutId = exercise?.workout;
    const snapshot = existing?.exercisesSnapshot ? [...existing.exercisesSnapshot] : [];
    if (!snapshot.includes(entry.exerciseId)) {
      snapshot.push(entry.exerciseId);
    }
    const resolvedWorkout =
      existing?.workoutId === "Custom"
        ? "Custom"
        : existing?.workoutId && workoutId && existing.workoutId !== workoutId
          ? "Custom"
          : existing?.workoutId ?? workoutId;
    const now = Date.now();
    sessionsStore.put({
      date: entry.date,
      workoutId: resolvedWorkout,
      createdAtTs: existing?.createdAtTs ?? entry.ts,
      updatedAtTs: Math.max(existing?.updatedAtTs ?? 0, now),
      notes: existing?.notes,
      exercisesSnapshot: snapshot.length ? snapshot : undefined,
    });
  }

  await transactionDone(tx);
  notifyDbChange("addSet");
};

export const updateSet = async (entry: SetEntry) => {
  const db = await openDb();
  const tx = db.transaction("sets", "readwrite");
  tx.objectStore("sets").put(entry);
  await transactionDone(tx);
  notifyDbChange("updateSet");
};

export const deleteSet = async (id: string) => {
  const db = await openDb();
  const storeNames: Array<"sets" | "sessions"> = ["sets"];
  const hasSessions = db.objectStoreNames.contains("sessions");
  if (hasSessions) storeNames.push("sessions");
  const tx = db.transaction(storeNames, "readwrite");
  const setStore = tx.objectStore("sets");
  const existing = await requestToPromise<SetEntry | undefined>(setStore.get(id));
  if (!existing) {
    await transactionDone(tx);
    return;
  }
  setStore.delete(id);
  if (hasSessions) {
    const sessionsStore = tx.objectStore("sessions");
    const remaining = await requestToPromise<number>(
      setStore.index("date").count(existing.date),
    );
    if (remaining === 0) {
      sessionsStore.delete(existing.date);
    }
  }
  await transactionDone(tx);
  notifyDbChange("deleteSet");
};

export const getAllSets = async () => {
  const db = await openDb();
  const tx = db.transaction("sets", "readonly");
  const store = tx.objectStore("sets");
  const items = await requestToPromise<SetEntry[]>(store.getAll());
  await transactionDone(tx);
  return items.sort((a, b) => b.ts - a.ts);
};

export const querySetsByDate = async (date: string) => {
  const db = await openDb();
  const tx = db.transaction("sets", "readonly");
  const store = tx.objectStore("sets");
  const items = await requestToPromise<SetEntry[]>(
    store.index("date").getAll(date),
  );
  await transactionDone(tx);
  return items.sort((a, b) => b.ts - a.ts);
};

export const querySetsByExercise = async (exerciseId: string) => {
  const db = await openDb();
  const tx = db.transaction("sets", "readonly");
  const store = tx.objectStore("sets");
  const items = await requestToPromise<SetEntry[]>(
    store.index("exerciseId").getAll(exerciseId),
  );
  await transactionDone(tx);
  return items.sort((a, b) => b.ts - a.ts);
};

export const getSession = async (date: string) => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) return null;
  const tx = db.transaction("sessions", "readonly");
  const store = tx.objectStore("sessions");
  const item = await requestToPromise<SessionEntry | undefined>(store.get(date));
  await transactionDone(tx);
  return item ?? null;
};

export const getAllSessions = async () => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) return [] as SessionEntry[];
  const tx = db.transaction("sessions", "readonly");
  const store = tx.objectStore("sessions");
  const items = await requestToPromise<SessionEntry[]>(store.getAll());
  await transactionDone(tx);
  return items.sort((a, b) => (a.date < b.date ? 1 : -1));
};

export const saveSession = async (session: SessionEntry) => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) return;
  const tx = db.transaction("sessions", "readwrite");
  tx.objectStore("sessions").put(session);
  await transactionDone(tx);
  notifyDbChange("saveSession");
};

export const saveSessions = async (sessions: SessionEntry[]) => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) return;
  const tx = db.transaction("sessions", "readwrite");
  const store = tx.objectStore("sessions");
  sessions.forEach((session) => store.put(session));
  await transactionDone(tx);
  notifyDbChange("saveSessions");
};

export const deleteSession = async (date: string) => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) return;
  const tx = db.transaction("sessions", "readwrite");
  tx.objectStore("sessions").delete(date);
  await transactionDone(tx);
  notifyDbChange("deleteSession");
};

export const listSessions = async (options: {
  limit: number;
  before?: string;
}) => {
  const db = await openDb();
  if (!db.objectStoreNames.contains("sessions")) {
    return { sessions: [] as SessionEntry[], hasMore: false };
  }
  const tx = db.transaction("sessions", "readonly");
  const store = tx.objectStore("sessions");
  const done = transactionDone(tx);
  const sessions: SessionEntry[] = [];
  const range = options.before
    ? IDBKeyRange.upperBound(options.before, true)
    : undefined;
  const result = await new Promise<{ sessions: SessionEntry[]; hasMore: boolean }>(
    (resolve, reject) => {
      const request = store.openCursor(range, "prev");
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const cursor = request.result;
        if (!cursor) {
          resolve({ sessions, hasMore: false });
          return;
        }
        sessions.push(cursor.value as SessionEntry);
        if (sessions.length > options.limit) {
          resolve({ sessions: sessions.slice(0, options.limit), hasMore: true });
          return;
        }
        cursor.continue();
      };
    },
  );
  await done;
  return result;
};

export const deleteSessionWithSets = async (date: string) => {
  const db = await openDb();
  const storeNames: Array<"sets" | "sessions"> = ["sets"];
  if (db.objectStoreNames.contains("sessions")) {
    storeNames.push("sessions");
  }
  const tx = db.transaction(storeNames, "readwrite");
  const setStore = tx.objectStore("sets");
  const dateIndex = setStore.index("date");
  const request = dateIndex.openCursor(IDBKeyRange.only(date));
  request.onsuccess = () => {
    const cursor = request.result;
    if (!cursor) return;
    cursor.delete();
    cursor.continue();
  };
  if (db.objectStoreNames.contains("sessions")) {
    tx.objectStore("sessions").delete(date);
  }
  await transactionDone(tx);
  notifyDbChange("deleteSessionWithSets");
};

export const getSetting = async <T = unknown>(key: string) => {
  const db = await openDb();
  const tx = db.transaction("settings", "readonly");
  const store = tx.objectStore("settings");
  const item = await requestToPromise<{ key: string; value: T } | undefined>(
    store.get(key),
  );
  await transactionDone(tx);
  return item?.value ?? null;
};

export const getAllSettings = async (): Promise<Partial<SettingsState>> => {
  const db = await openDb();
  const tx = db.transaction("settings", "readonly");
  const store = tx.objectStore("settings");
  const items = await requestToPromise<Array<{ key: string; value: unknown }>>(
    store.getAll(),
  );
  await transactionDone(tx);
  return items.reduce<Partial<SettingsState>>((acc, item) => {
    acc[item.key as keyof SettingsState] = item.value as never;
    return acc;
  }, {});
};

export const setSetting = async <T = unknown>(key: string, value: T) => {
  const db = await openDb();
  const tx = db.transaction("settings", "readwrite");
  tx.objectStore("settings").put({ key, value });
  await transactionDone(tx);
  notifyDbChange("setSetting");
};

export const setSettings = async (settings: Partial<SettingsState>) => {
  const db = await openDb();
  const tx = db.transaction("settings", "readwrite");
  const store = tx.objectStore("settings");
  Object.entries(settings).forEach(([key, value]) => {
    store.put({ key, value });
  });
  await transactionDone(tx);
  notifyDbChange("setSettings");
};

export const getMirrorHandle = async (): Promise<FileSystemFileHandle | null> => {
  const db = await openDb();
  const tx = db.transaction("mirror", "readonly");
  const store = tx.objectStore("mirror");
  const item = await requestToPromise<{ key: string; value: FileSystemFileHandle } | undefined>(
    store.get("handle"),
  );
  await transactionDone(tx);
  return item?.value ?? null;
};

export const setMirrorHandle = async (handle: FileSystemFileHandle | null) => {
  const db = await openDb();
  const tx = db.transaction("mirror", "readwrite");
  const store = tx.objectStore("mirror");
  if (handle) {
    store.put({ key: "handle", value: handle });
  } else {
    store.delete("handle");
  }
  await transactionDone(tx);
};

export const getMirrorLastWrite = async (): Promise<number | null> => {
  const db = await openDb();
  const tx = db.transaction("mirror", "readonly");
  const store = tx.objectStore("mirror");
  const item = await requestToPromise<{ key: string; value: number } | undefined>(
    store.get("lastWrite"),
  );
  await transactionDone(tx);
  return item?.value ?? null;
};

export const setMirrorLastWrite = async (lastWrite: number | null) => {
  const db = await openDb();
  const tx = db.transaction("mirror", "readwrite");
  const store = tx.objectStore("mirror");
  if (lastWrite !== null) {
    store.put({ key: "lastWrite", value: lastWrite });
  } else {
    store.delete("lastWrite");
  }
  await transactionDone(tx);
};

export const clearAllData = async () => {
  const db = await openDb();
  const tx = db.transaction(
    ["exercises", "sets", "sessions", "settings", "mirror"],
    "readwrite",
  );
  tx.objectStore("exercises").clear();
  tx.objectStore("sets").clear();
  tx.objectStore("sessions").clear();
  tx.objectStore("settings").clear();
  tx.objectStore("mirror").clear();
  await transactionDone(tx);
  notifyDbChange("clearAllData");
};

#### END lib/db/index.ts ####

#### START lib/defaults.ts ####

import type { Exercise, SettingsState } from "./types";

export const DEFAULT_BAR_LB = 45;
export const DEFAULT_WEIGHT_PRESETS = [25, 35, 45, 55, 65, 75, 85, 95];
export const DEFAULT_REP_PRESETS = [3, 5, 8, 10, 12, 15];
export const DEFAULT_TAGS = ["easy", "pause", "slow"];

export const defaultSettings: SettingsState = {
  barLb: DEFAULT_BAR_LB,
  unitDisplay: "both",
  roundingKg: 0.1,
  e1rmFormula: "epley",
  weightPresets: DEFAULT_WEIGHT_PRESETS,
  repPresets: DEFAULT_REP_PRESETS,
  lastWorkout: undefined,
  onboarded: false,
};

export const createDefaultExercises = (): Exercise[] => {
  const now = Date.now();
  return [
    {
      id: crypto.randomUUID(),
      name: "Squat",
      type: "barbell",
      workout: "A",
      perSide: true,
      order: 0,
      createdAt: now,
    },
    {
      id: crypto.randomUUID(),
      name: "Bench Press",
      type: "barbell",
      workout: "A",
      perSide: true,
      order: 1,
      createdAt: now,
    },
    {
      id: crypto.randomUUID(),
      name: "Lat Pulldown",
      type: "machine",
      workout: "A",
      perSide: false,
      order: 2,
      createdAt: now,
    },
    {
      id: crypto.randomUUID(),
      name: "Deadlift",
      type: "barbell",
      workout: "B",
      perSide: true,
      order: 0,
      createdAt: now,
    },
    {
      id: crypto.randomUUID(),
      name: "Overhead Press",
      type: "barbell",
      workout: "B",
      perSide: true,
      order: 1,
      createdAt: now,
    },
    {
      id: crypto.randomUUID(),
      name: "Row",
      type: "barbell",
      workout: "B",
      perSide: true,
      order: 2,
      createdAt: now,
    },
  ];
};

#### END lib/defaults.ts ####

#### START lib/fileMirror.ts ####

import { serializeBackup } from "./backup";
import {
  getAllExercises,
  getAllSessions,
  getAllSets,
  getAllSettings,
  getMirrorHandle,
  getMirrorLastWrite,
  setMirrorHandle,
  setMirrorLastWrite,
} from "./db";
import { defaultSettings } from "./defaults";
import type { SettingsState } from "./types";

export type FileMirrorState = {
  supported: boolean;
  enabled: boolean;
  fileName: string | null;
  lastWrite: number | null;
};

export type FileMirrorEnableResult =
  | { ok: true }
  | { ok: false; reason: "unsupported" | "cancelled" | "permission" | "failed" };

export type FileMirrorWriteResult =
  | { ok: true; lastWrite: number }
  | { ok: false; reason: "unsupported" | "not-enabled" | "permission" | "write-failed" };

type FileSystemHandleWithPermissions = FileSystemFileHandle & {
  queryPermission?: (descriptor?: { mode?: "read" | "readwrite" }) => Promise<PermissionState>;
  requestPermission?: (descriptor?: { mode?: "read" | "readwrite" }) => Promise<PermissionState>;
};

type FilePickerOptions = {
  suggestedName?: string;
  types?: Array<{
    description?: string;
    accept: Record<string, string[]>;
  }>;
  excludeAcceptAllOption?: boolean;
};

type FilePickerWindow = Window &
  typeof globalThis & {
    showSaveFilePicker?: (options?: FilePickerOptions) => Promise<FileSystemFileHandle>;
  };

let writePromise: Promise<FileMirrorWriteResult> | null = null;

export const isFileMirrorSupported = () =>
  typeof window !== "undefined" && "showSaveFilePicker" in window;

const mirrorTypes: NonNullable<FilePickerOptions["types"]> = [
  {
    description: "Gym log (JSON)",
    accept: { "application/json": [".json"] },
  },
];

const ensureHandlePermission = async (handle: FileSystemFileHandle) => {
  const permissionHandle = handle as FileSystemHandleWithPermissions;
  const options = { mode: "readwrite" as const };
  if (typeof permissionHandle.queryPermission !== "function") return true;
  const current = await permissionHandle.queryPermission(options);
  if (current === "granted") return true;
  if (typeof permissionHandle.requestPermission !== "function") return false;
  const requested = await permissionHandle.requestPermission(options);
  return requested === "granted";
};

const buildMirrorPayload = async () => {
  const [exercises, sessions, sets, settingsData] = await Promise.all([
    getAllExercises(),
    getAllSessions(),
    getAllSets(),
    getAllSettings(),
  ]);
  const settings = { ...defaultSettings, ...settingsData } as SettingsState;
  const payload = serializeBackup(exercises, sets, settings, sessions, {
    pretty: true,
  });
  return payload;
};

const writeMirrorWithHandle = async (
  handle: FileSystemFileHandle,
): Promise<FileMirrorWriteResult> => {
  const allowed = await ensureHandlePermission(handle);
  if (!allowed) return { ok: false, reason: "permission" };
  try {
    const payload = await buildMirrorPayload();
    const writable = await handle.createWritable();
    await writable.write(payload);
    await writable.close();
  } catch (error) {
    console.error(error);
    return { ok: false, reason: "write-failed" };
  }
  const lastWrite = Date.now();
  await setMirrorLastWrite(lastWrite);
  return { ok: true, lastWrite };
};

export const getFileMirrorState = async (): Promise<FileMirrorState> => {
  if (!isFileMirrorSupported()) {
    return {
      supported: false,
      enabled: false,
      fileName: null,
      lastWrite: null,
    };
  }
  const [handle, lastWrite] = await Promise.all([
    getMirrorHandle(),
    getMirrorLastWrite(),
  ]);
  return {
    supported: true,
    enabled: Boolean(handle),
    fileName: handle?.name ?? null,
    lastWrite: lastWrite ?? null,
  };
};

export const enableFileMirror = async (): Promise<FileMirrorEnableResult> => {
  if (!isFileMirrorSupported()) {
    return { ok: false, reason: "unsupported" };
  }
  let handle: FileSystemFileHandle;
  try {
    const pickerWindow = window as FilePickerWindow;
    if (!pickerWindow.showSaveFilePicker) {
      return { ok: false, reason: "unsupported" };
    }
    handle = await pickerWindow.showSaveFilePicker({
      suggestedName: "gym-log.json",
      types: mirrorTypes,
      excludeAcceptAllOption: true,
    });
  } catch (error) {
    if (error instanceof DOMException && error.name === "AbortError") {
      return { ok: false, reason: "cancelled" };
    }
    console.error(error);
    return { ok: false, reason: "failed" };
  }
  const allowed = await ensureHandlePermission(handle);
  if (!allowed) return { ok: false, reason: "permission" };
  await setMirrorHandle(handle);
  return { ok: true };
};

export const disableFileMirror = async () => {
  await setMirrorHandle(null);
  await setMirrorLastWrite(null);
};

export const writeFileMirrorNow = async (): Promise<FileMirrorWriteResult> => {
  if (writePromise) return writePromise;
  writePromise = (async () => {
    try {
      if (!isFileMirrorSupported()) {
        return { ok: false, reason: "unsupported" };
      }
      const handle = await getMirrorHandle();
      if (!handle) return { ok: false, reason: "not-enabled" };
      return writeMirrorWithHandle(handle);
    } catch (error) {
      console.error(error);
      return { ok: false, reason: "write-failed" };
    }
  })();
  try {
    return await writePromise;
  } finally {
    writePromise = null;
  }
};

#### END lib/fileMirror.ts ####

#### START lib/types.ts ####

export type ExerciseType = "barbell" | "dumbbell" | "machine" | "bodyweight";
export type WorkoutId = "A" | "B" | "Custom";
export type UnitDisplay = "both" | "lb" | "kg";
export type E1RMFormula = "epley" | "brzycki";

export type Exercise = {
  id: string;
  name: string;
  type: ExerciseType;
  workout: WorkoutId;
  perSide?: boolean;
  order: number;
  createdAt: number;
};

export type SetEntry = {
  id: string;
  ts: number;
  date: string;
  exerciseId: string;
  reps: number;
  inputLb: number;
  barLbSnapshot: number;
  totalLb: number;
  totalKg: number;
  note?: string;
  tags?: string[];
  meta?: {
    rpe?: number;
  };
};

export type SessionEntry = {
  date: string;
  workoutId?: WorkoutId;
  createdAtTs: number;
  updatedAtTs: number;
  notes?: string;
  exercisesSnapshot?: string[];
};

export type SettingsState = {
  barLb: number;
  unitDisplay: UnitDisplay;
  roundingKg: number;
  e1rmFormula: E1RMFormula;
  weightPresets: number[];
  repPresets: number[];
  lastWorkout?: WorkoutId;
  activeSessionDate?: string;
  onboarded?: boolean;
};

export type BackupPayload = {
  version: number;
  exportedAt: number;
  exercises: Exercise[];
  sets: SetEntry[];
  sessions?: SessionEntry[];
  settings: SettingsState;
};

#### END lib/types.ts ####

#### START next.config.ts ####

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

#### END next.config.ts ####

#### START package.json ####

{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "next": "16.1.4",
    "react": "19.2.3",
    "react-dom": "19.2.3"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.4",
    "tailwindcss": "^4",
    "typescript": "^5"
  },
  "ignoreScripts": [
    "sharp",
    "unrs-resolver"
  ],
  "trustedDependencies": [
    "sharp",
    "unrs-resolver"
  ]
}

#### END package.json ####

#### START postcss.config.mjs ####

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;

#### END postcss.config.mjs ####

#### START public/manifest.json ####

{
  "name": "Gym Log",
  "short_name": "Gym Log",
  "description": "Low-tap gym logging with barbell math built in.",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0b0d10",
  "theme_color": "#0b0d10",
  "icons": [
    {
      "src": "/icons/icon-192.svg",
      "sizes": "192x192",
      "type": "image/svg+xml",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.svg",
      "sizes": "512x512",
      "type": "image/svg+xml",
      "purpose": "any maskable"
    }
  ]
}

#### END public/manifest.json ####

#### START public/sw.js ####

const CACHE_NAME = "gymlog-cache-v2";
const CORE_ASSETS = [
  "/",
  "/history",
  "/progress",
  "/settings",
  "/manifest.json",
  "/icons/icon-192.svg",
  "/icons/icon-512.svg",
];

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(CORE_ASSETS)),
  );
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.all(
          keys.filter((key) => key !== CACHE_NAME).map((key) => caches.delete(key)),
        ),
      )
      .then(() => self.clients.claim()),
  );
});

self.addEventListener("fetch", (event) => {
  const { request } = event;
  if (request.method !== "GET") return;

  if (request.mode === "navigate") {
    event.respondWith(
      fetch(request)
        .then((response) => {
          const copy = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put("/", copy));
          return response;
        })
        .catch(() => caches.match("/")),
    );
    return;
  }

  event.respondWith(
    caches.match(request).then((cached) => {
      if (cached) return cached;
      return fetch(request)
        .then((response) => {
          if (
            response &&
            response.status === 200 &&
            response.type === "basic"
          ) {
            const copy = response.clone();
            caches.open(CACHE_NAME).then((cache) => cache.put(request, copy));
          }
          return response;
        })
        .catch(() => cached);
    }),
  );
});

#### END public/sw.js ####

#### START tsconfig.json ####

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}

#### END tsconfig.json ####

